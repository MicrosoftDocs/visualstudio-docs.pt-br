---
title: Avisos de design
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 5dc55cc72f7f37482b4396784ca90dba773fdcee
ms.sourcegitcommit: 5ab22b8601db9c420691f8e57abe140e837aa720
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/24/2020
ms.locfileid: "82109462"
---
# <a name="design-warnings"></a>Avisos de design

Os avisos de design dão suporte à adesão às [diretrizes de design de .NET Framework](/dotnet/standard/design-guidelines/).

## <a name="in-this-section"></a>Nesta seção

| Regra | Descrição |
| - | - |
| [CA1000: não declarar membros estáticos em tipos genéricos](../code-quality/ca1000.md) | Quando um membro estático de um tipo genérico é chamado, o argumento de tipo deve ser especificado para o tipo. Quando um membro de instância genérico que não dá suporte à inferência é chamado, o argumento de tipo deve ser especificado para o membro. Nesses dois casos, a sintaxe para especificar o argumento de tipo é diferente e facilmente confundida. |
| [CA1001: tipos que têm campos descartáveis devem ser descartáveis](../code-quality/ca1001.md) | Uma classe declara e implementa um campo de instância que é um tipo System. IDisposable e a classe não implementa IDisposable. Uma classe que declara um campo IDisposable indiretamente possui um recurso não gerenciado e deve implementar a interface IDisposable. |
| [CA1002: não expor listas genéricas](../code-quality/ca1002.md) | System. Collections. Generic. List< (Of \<(T>) >) é uma coleção genérica que é projetada para desempenho, não herança. Por isso, List não contém membros virtuais. As coleções genéricas projetadas para herança devem ser expostas em seu lugar. |
| [CA1003: usar instâncias do manipulador de eventos genéricos](../code-quality/ca1003.md) | Um tipo contém um delegado que retorna void, cuja assinatura contém dois parâmetros (o primeiro objeto e o segundo um tipo que pode ser atribuído a EventArgs) e o assembly de destinos que o contém .NET Framework 2,0. |
| [CA1004: os métodos genéricos devem fornecer o parâmetro de tipo](../code-quality/ca1004.md) | Inferência é como o argumento de tipo de um método genérico é determinado pelo tipo de argumento passado para o método, em vez da especificação explícita do argumento de tipo. Para habilitar a inferência, a assinatura do parâmetro de um método genérico deve incluir um parâmetro que seja do mesmo tipo do parâmetro de tipo para o método. Nesse caso, o argumento de tipo não precisa ser especificado. Quando você usa a inferência para todos os parâmetros de tipo, a sintaxe para chamar métodos de instância genéricos e não genéricos é idêntica; Isso simplifica a usabilidade de métodos genéricos. |
| [CA1005: evitar parâmetros excessivos em tipos genéricos](../code-quality/ca1005.md) | Quanto mais parâmetros de tipo um tipo genérico contiver, mais difícil será saber e lembrar-se do que cada parâmetro de tipo representa. Normalmente, é óbvio com um parâmetro de tipo, como na\<lista T> e, em certos casos, com dois parâmetros de tipo,\<como no Dictionary TKey, TValue>. No entanto, se houver mais de dois parâmetros de tipo, a dificuldade ficará muito grande para a maioria dos usuários. |
| [CA1006: não aninhar tipos genéricos em assinaturas de membro](../code-quality/ca1006.md) | Um argumento de tipo aninhado é um argumento de tipo que também é um tipo genérico. Para chamar um membro cuja assinatura contenha um argumento de tipo aninhado, o usuário deve criar uma instância de um tipo genérico e passar esse tipo para o construtor de um segundo tipo genérico. O procedimento e a sintaxe obrigatórios são complexos e devem ser evitados. |
| [CA1007: usar genéricos quando apropriado](../code-quality/ca1007.md) | Um método visível externamente contém um parâmetro de referência do tipo System.Object. O uso de um método genérico permite que todos os tipos, sujeitos a restrições, sejam passados para o método sem primeiramente converter o tipo no tipo de parâmetro de referência. |
| [CA1008: as enums devem ter valor zero](../code-quality/ca1008.md) | O valor padrão de uma enumeração não inicializada, assim como o de outros tipos de valor, é zero. Uma enumeração atribuída não sinalizações deve definir um membro usando o valor de zero para que o valor padrão seja um valor válido da enumeração. Se uma enumeração que tem o atributo FlagsAttribute aplicado definir um membro com valor, seu nome deverá ser “None” para indicar que nenhum valor foi definido na enumeração. |
| [CA1009: declarar manipuladores de eventos corretamente](../code-quality/ca1009.md) | Os métodos de manipulador de eventos utilizam dois parâmetros. O primeiro é do tipo System.Object e é chamado de "sender". Este é o objeto que acionou o evento. O segundo parâmetro é do tipo System.EventArgs e é chamado de "e". Esses são os dados associados ao evento. Os métodos do manipulador de eventos não devem retornar um valor; na linguagem de programação C#, isso é indicado pelo tipo de retorno nulo. |
| [CA1010: as coleções devem implementar a interface genérica](../code-quality/ca1010.md) | Para ampliar a usabilidade de uma coleção, implemente uma das interfaces da coleção genéricas. Em seguida, a coleção pode ser usada para popular tipos de coleção genéricos. |
| [CA1011: considere a passagem dos tipos base como parâmetros](../code-quality/ca1011.md) | Quando um tipo de base é especificado como um parâmetro em uma declaração de método, qualquer tipo derivado do tipo de base pode ser passado como o argumento correspondente ao método. Se a funcionalidade adicional fornecida pelo tipo de parâmetro derivado não for necessária, o uso do tipo de base permitirá um uso mais amplo do método. |
| [CA1012: tipos abstratos não devem ter construtores](../code-quality/ca1012.md) | Construtores em tipos abstratos só podem ser chamados por tipos derivados. Como construtores públicos criam instâncias de um tipo e não é possível criar instâncias de um tipo abstrato, um tipo abstrato com um construtor público é projetado incorretamente. |
| [CA1013: sobrecarregar igualdades de operador em add e subtract de sobrecarga](../code-quality/ca1013.md) | Um tipo público ou protegido implementa os operadores de adição ou subtração sem implementar o operador de igualdade. |
| [CA1014: marcar assemblies com CLSCompliantAttribute](../code-quality/ca1014.md) | A CLS (Common Language Specification) define restrições de nomenclatura, tipos de dados e regras que assemblies deverão respeitar se forem usados em todas as linguagens de programação. Um bom design dita que todos os assemblies indicam explicitamente a conformidade com CLS usando o CLSCompliantAttribute. Se esse atributo não estiver presente em um assembly, o assembly não será compatível. |
| [CA1016: marcar assemblies com AssemblyVersionAttribute](../code-quality/ca1016.md) | O .NET usa o número de versão para identificar exclusivamente um assembly e para associar a tipos em assemblies com nomes de alta segurança. O número de versão é usado com a versão e a política do publicador. Por padrão, os aplicativos só são executados com a versão do assembly com que foram criados. |
| [CA1017: marcar assemblies com ComVisibleAttribute](../code-quality/ca1017.md) | ComVisibleAttribute determina como clientes COM acessam código gerenciado. Um bom design determina que os assemblies indiquem explicitamente a visibilidade de COM. A visibilidade de COM pode ser definida para todo o assembly e, em seguida, substituída por tipos individuais e membros de tipo. Caso esse atributo não esteja presente, o conteúdo do assembly permanece visível aos clientes COM. |
| [CA1018: marcar atributos com AttributeUsageAttribute](../code-quality/ca1018.md) | Ao definir um atributo personalizado, você o marca usando AttributeUsageAttribute para indicar onde o atributo personalizado pode ser aplicado no código-fonte. O significado e o uso desejado de um atributo determinarão seus locais válidos no código. |
| [CA1019: definir acessadores para argumentos de atributo](../code-quality/ca1019.md) | Os atributos podem definir argumentos obrigatórios que devem ser especificados quando você aplica o atributo a um destino. Eles também são conhecidos como argumentos posicionais porque são fornecidos a construtores de atributos como parâmetros posicionais. Para cada argumento obrigatório, o atributo também deve fornecer uma propriedade somente leitura correspondente de forma que o valor do argumento possa ser recuperado no tempo de execução. Os atributos também podem definir argumentos opcionais, que também são conhecidos como argumentos nomeados. Esses argumentos são fornecidos a construtores de atributo por nome e devem ter uma propriedade de leitura/gravação correspondente. |
| [CA1020: evitar namespaces com poucos tipos](../code-quality/ca1020.md) | Certifique-se de que cada um dos seus namespaces tenha uma organização lógica e que você tenha um motivo válido para colocar os tipos em um namespace populadamente preenchido. |
| [CA1021: evitar parâmetros de saída](../code-quality/ca1021.md) | A passagem de tipos por referência (usando out ou ref) requer experiência com ponteiros, compreensão das diferenças entre tipos de valor e tipos de referência e os métodos de tratamento com vários valores de retorno. Além disso, a diferença entre parâmetros out e ref não é amplamente compreendida. |
| [CA1023: os indexadores não devem ser multidimensionais](../code-quality/ca1023.md) | Os indicadores (ou seja, propriedades indexadas) devem usar um único índice. Os indicadores multidimensionais podem reduzir significativamente a usabilidade da biblioteca. |
| [CA1024: usar propriedades quando apropriado](../code-quality/ca1024.md) | Um método público ou protegido tem um nome que começa com "Get", não utiliza parâmetros e retorna um valor que não é uma matriz. O método pode ser um bom candidato a se tornar uma propriedade. |
| [CA1025: substituir argumentos repetitivos por matriz de parâmetros](../code-quality/ca1025.md) | Use uma matriz de parâmetros, em vez de argumentos repetidos, quando o número exato de argumentos for desconhecido e quando os argumentos variáveis forem do mesmo tipo ou puderem ser passados como o mesmo tipo. |
| [CA1026: parâmetros padrão não devem ser usados](../code-quality/ca1026.md) | Métodos que usam parâmetros padrão são permitidos na CLS; no entanto, a CLS permite que os compiladores ignorem os valores que são atribuídos a esses parâmetros. Para manter o comportamento desejado em todas as linguagens de programação, os métodos que usam parâmetros padrão devem ser substituídos por sobrecargas de método que forneçam os parâmetros padrão. |
| [CA1027: marcar enums com FlagsAttribute](../code-quality/ca1027.md) | Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas. Aplique FlagsAttribute a uma enumeração quando suas constantes nomeadas puderem ser combinadas de maneira significativa. |
| [CA1028: o armazenamento de enum deve ser Int32](../code-quality/ca1028.md) | Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas. Por padrão, o tipo de dados System.Int32 é usado para armazenar o valor constante. Embora você possa alterar esse tipo subjacente, ele não é obrigatório ou recomendado para a maioria dos cenários. |
| [CA1030: usar eventos quando apropriado](../code-quality/ca1030.md) | Essa regra detecta métodos que têm nomes que seriam usados normalmente em eventos. Se um método for chamado em resposta a uma alteração de estado claramente definida, o método deverá ser invocado por um manipulador de eventos. Os objetos que chamam o método devem acionar eventos, em vez de chamar o método diretamente. |
| [CA1031: não capturar tipos de exceção gerais](../code-quality/ca1031.md) | As exceções gerais não devem ser capturadas. Pegue uma exceção mais específica ou relance a exceção geral como a última instrução no bloco catch. |
| [CA1032: implementar construtores de exceção padrão](../code-quality/ca1032.md) | Deixar de fornecer o conjunto completo de construtores pode dificultar o tratamento correto das exceções. |
| [CA1033: os métodos de interface devem ser chamáveis por tipos filho](../code-quality/ca1033.md) | Um tipo visível externamente sem lacre fornece uma implementação de método explícita de uma interface pública e não fornece um método visível externamente alternativo com o mesmo nome. |
| [CA1034: os tipos aninhados não devem ser visíveis](../code-quality/ca1034.md) | Um tipo aninhado é um tipo declarado no escopo de outro tipo. Os tipos aninhados são úteis para encapsular detalhes de implementação privados do tipo de contenção. Usados para essa finalidade, os tipos aninhados não devem ser visíveis externamente. |
| [CA1035: as implementações de ICollection têm membros fortemente tipados](../code-quality/ca1035.md) | Essa regra exige que implementações de ICollection forneçam membros fortemente tipados de forma que usuários não sejam obrigados a converter argumentos no tipo Object quando usarem a funcionalidade fornecida pela interface. Essa regra pressupõe que o tipo que implementa ICollection faça isso para gerenciar uma coleção de instâncias de um tipo mais forte que Object. |
| [CA1036: substituir métodos em tipos comparáveis](../code-quality/ca1036.md) | Um público ou um tipo protegido implementa a interface System.IComparable. Ele não substitui Object.Equals nem sobrecarrega o operador específico da linguagem para igualdade, desigualdade, menor que ou maior que. |
| [CA1038: os enumeradores devem ser fortemente tipados](../code-quality/ca1038.md) | Essa regra exige que implementações de IEnumerator também forneçam uma versão fortemente tipada da propriedade Current de forma que usuários não sejam obrigados a converter o valor de retorno no tipo forte quando usarem a funcionalidade fornecida pela interface. |
| [CA1039: as listas são fortemente tipadas](../code-quality/ca1039.md) | Essa regra exige que implementações de IList forneçam membros fortemente tipados de forma que usuários não sejam obrigados a converter argumentos no tipo System.Object quando usarem a funcionalidade fornecida pela interface. |
| [CA1040: evitar interfaces vazias](../code-quality/ca1040.md) | As interfaces definem os membros que fornecem um contrato de comportamento ou de uso. A funcionalidade descrita pela interface pode ser adotada por qualquer tipo, independentemente de onde o tipo seja exibido na hierarquia de herança. Um tipo implementa uma interface fornecendo implementações para os membros da interface. Uma interface vazia não define membros; por isso, ela não define um contrato que pode ser implementado. |
| [CA1041: fornecer mensagem ObsoleteAttribute](../code-quality/ca1041.md) | Um tipo ou um membro é marcado usando-se um atributo System.ObsoleteAttribute que não tem sua propriedade ObsoleteAttribute.Message especificada. Quando um tipo ou membro que é marcado usando ObsoleteAttribute é compilado, a propriedade Message do atributo é exibida, o que fornece as informações do usuário sobre o tipo ou o membro obsoleto. |
| [CA1043: usar argumento integral ou da cadeia de caracteres para indexadores](../code-quality/ca1043.md) | Os indicadores (ou seja, propriedades indexadas) devem usar tipos integrais ou de cadeia de caracteres no índice. Esses tipos normalmente são usados na indexação de estruturas de dados e aumentam a usabilidade da biblioteca. O uso do tipo Object deve ser restrito a esses casos em que o tipo integral ou de cadeia de caracteres específico não pode ser especificado no tempo de design. |
| [CA1044: as propriedades não devem ser somente leitura](../code-quality/ca1044.md) | Embora seja aceitável e normalmente necessário ter uma propriedade somente leitura, as diretrizes de design proíbem o uso de propriedades somente gravação. Isso é porque a permissão para que um usuário defina um valor e o impedimento posterior para ele exiba esse valor não dão nenhuma segurança. Além disso, sem acesso de leitura, o estado de objetos compartilhados não pode ser exibido, o que limita sua utilidade. |
| [CA1045: não passar tipos por referência](../code-quality/ca1045.md) | A passagem de tipos por referência (usando out ou ref) requer experiência com ponteiros, compreensão das diferenças entre tipos de valor e tipos de referência e os métodos de tratamento com vários valores de retorno. Os arquitetos de bibliotecas que projetam para um público em geral não devem esperar que os usuários dominem o trabalho com parâmetros out ou ref. |
| [CA1046: não sobrecarregar igualdades de operador em tipos de referência](../code-quality/ca1046.md) | Para tipos de referência, a implementação padrão do operador de igualdade está quase sempre correta. Por padrão, duas referências só serão iguais se apontarem para o mesmo objeto. |
| [CA1047: não declarar membros protegidos em tipos lacrados](../code-quality/ca1047.md) | Os tipos declaram membros protegidos de forma que a herança de tipos possa acessar ou substituir o membro. Por definição, os tipos vedados não podem ser lacrados, o que significa que os métodos protegidos em tipos lacrados não podem ser chamados. |
| [CA1048: não declarar membros virtuais em tipos lacrados](../code-quality/ca1048.md) | Os tipos declaram métodos como virtuais de forma que a herança de tipos possa substituir a implementação do método virtual. Por definição, um tipo lacrado não pode ser herdado. Isso torna um método virtual em um tipo lacrado sem sentido. |
| [CA1049: tipos que tenham recursos nativos devem ser descartáveis](../code-quality/ca1049.md) | Tipos que alocam recursos não gerenciados devem implementar IDisposable para permitir que os chamadores liberem esses recursos sob demanda e reduzir o tempo de vida dos objetos que contêm os recursos. |
| [CA1050: declarar tipos em namespaces](../code-quality/ca1050.md) | Tipos são declarados em namespaces para evitar conflitos de nome e são uma maneira de organizar tipos relacionados em uma hierarquia de objetos. |
| [CA1051: não declarar campos de instância visíveis](../code-quality/ca1051.md) | O principal uso de um campo deve ser um como um detalhe da implementação. Os campos devem ser privados ou internos e devem ser expostos usando-se propriedades. |
| [CA1052: os tipos de suporte estático devem ser lacrados](../code-quality/ca1052.md) | Um tipo público ou protegido contém apenas membros estáticos e não é declarado usando o modificador lacrado (C#) ou NotInheritable (Visual Basic). Um tipo que não é deve ser herdado deve ser marcado usando-se o modificador lacrado para evitar seu uso como um tipo de base. |
| [CA1053: os tipos de suporte estático não devem ter construtores](../code-quality/ca1053.md) | Um tipo público ou público aninhado declara apenas membros estáticos e tem um construtor padrão público ou protegido. O construtor é desnecessário porque chamar membros estáticos não exige uma instância do tipo. A sobrecarga de cadeia de caracteres deve chamar a sobrecarga do URI (Uniform Resource Identifier) usando-se o argumento de cadeia de caracteres por questões de segurança. |
| [CA1054: os parâmetros de URI não devem ser cadeias de caracteres](../code-quality/ca1054.md) | Se um método utilizar uma representação de cadeia de caracteres de um URI, uma sobrecarga correspondente deverá ser fornecida utilizando uma instância da classe do URI, que oferece esses serviços de maneira segura e protegida. |
| [CA1055: os valores de retorno de URI não devem ser cadeias de caracteres](../code-quality/ca1055.md) | Esta regra pressupõe que o método retorne um URI. Uma representação de cadeia de caracteres de um URI está propensa a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança. A classe System.Uri fornece esses serviços de maneira segura. |
| [CA1056: as propriedades de URI não devem ser cadeias de caracteres](../code-quality/ca1056.md) | Essa regra pressupõe que a propriedade representa um URI. Uma representação de cadeia de caracteres de um URI está propensa a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança. A classe System.Uri fornece esses serviços de maneira segura. |
| [CA1057: as sobrecargas de URI da cadeia de caracteres chamam sobrecargas System.Uri](../code-quality/ca1057.md) | Um tipo declara sobrecargas de método que diferem apenas pela substituição de um parâmetro de cadeia de caracteres com um parâmetro System.Uri. A sobrecarga que utiliza o parâmetro de cadeia de caracteres não chama a sobrecarga que utiliza o parâmetro do URI. |
| [CA1058: os tipos não devem estender determinados tipos base](../code-quality/ca1058.md) | Um tipo visível externamente estende determinados tipos de base. Use uma das alternativas. |
| [CA1059: os membros não devem expor determinados tipos concretos](../code-quality/ca1059.md) | Um tipo concreto é um tipo que tem uma implementação completa e, por isso, uma instância pode ser criada. Para permitir o uso difundido do membro, substitua o tipo concreto usando-se a interface sugerida. |
| [CA1060: mover P/Invokes para a classe NativeMethods](../code-quality/ca1060.md) | Os métodos de invocação de plataforma, como aqueles marcados <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> com os métodos ou definidos usando a palavra- [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]chave declare no, acessam código não gerenciado. Esses métodos devem ser da classe NativeMethods, SafeNativeMethods ou UnsafeNativeMethods. |
| [CA1061: não ocultar métodos de classe base](../code-quality/ca1061.md) | Um método em um tipo de base permanece oculto por um método nomeado identicamente em um tipo derivado, quando a assinatura do parâmetro do método derivado difere apenas pelos tipos derivados de maneira mais fraca do que os tipos correspondentes na assinatura do parâmetro do método de base. |
| [CA1062: validar argumentos de métodos públicos](../code-quality/ca1062.md) | Todos os argumentos de referência passados para os métodos visíveis externamente devem ser verificados em relação que serão nulos. |
| [CA1063: implementar IDisposable corretamente](../code-quality/ca1063.md) | Todos os tipos IDisposable devem implementar o padrão Dispose corretamente. |
| [CA1064: as exceções devem ser públicas](../code-quality/ca1064.md) | Uma exceção interna só permanece visível dentro do próprio escopo interno. Depois que a exceção falha fora do escopo interno, somente a exceção de base pode ser usada para capturar a exceção. Se a exceção interna for herdada <xref:System.Exception?displayProperty=fullName>de <xref:System.SystemException?displayProperty=fullName>, ou <xref:System.ApplicationException?displayProperty=fullName>, o código externo não terá informações suficientes para saber o que fazer com a exceção. |
| [CA1065: não acionar exceções em locais inesperados](../code-quality/ca1065.md) | Um método que não deve acionar exceções aciona uma exceção. |
| [CA1066: implementar IEquatable ao substituir Equals](../code-quality/ca1066.md) | Um tipo de valor <xref:System.Object.Equals%2A> substitui o método, mas não <xref:System.IEquatable%601>implementa. |
| [CA1067: substituir Equals ao implementar IEquatable](../code-quality/ca1067.md) | Um tipo implementa <xref:System.IEquatable%601>, mas não substitui <xref:System.Object.Equals%2A> o método. |
| [CA1068: os parâmetros de CancellationToken devem vir por último](../code-quality/ca1068.md) | Um método tem um parâmetro CancellationToken que não é o último parâmetro. |
| [CA2210: os assemblies devem ter nomes fortes válidos](../code-quality/ca2210.md) | O nome forte protege clientes do carregamento desconhecido de um assembly adulterado. Os assemblies sem nomes fortes não devem ser implantados fora de cenários muito limitados. Se você compartilhar ou distribuir assemblies não assinados corretamente, o assembly poderá ser adulterado, o Common Language Runtime poderá não carregar o assembly ou o usuário talvez precise desabilitar a verificação em seu computador. |
