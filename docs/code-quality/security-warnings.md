---
title: Avisos de segurança
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 93fc473550db227fe51eeeadc14c3006653c7e07
ms.sourcegitcommit: 96a6d1f16d06ca28d309d05b6e9fbd52f628cdbc
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 08/09/2018
ms.locfileid: "40008363"
---
# <a name="security-warnings"></a>Avisos de segurança

Os avisos de segurança oferecem suporte a bibliotecas e aplicativos mais seguros. Esses avisos ajudam a evitar falhas de segurança em seu programa. Se você desabilitar um desses avisos, você deve marcar claramente a razão no código e também informar o agente de segurança designado para seu projeto de desenvolvimento.

## <a name="in-this-section"></a>Nesta seção

|Regra|Descrição|
|----------|-----------------|
|[CA2100: examinar consultas SQL para vulnerabilidades de segurança](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md)|Um método define a propriedade System.Data.IDbCommand.CommandText usando uma cadeia de caracteres criada com base em um argumento da cadeia de caracteres para o método. Esta regra pressupõe que o argumento da cadeia de caracteres contenha a entrada do usuário. Uma cadeia de caracteres de comando SQL criada com base na entrada do usuário é vulnerável a ataques de injeção SQL.|
|[CA2102: capturar exceções que não sejam CLSCompliant em manipuladores gerais](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md)|Um membro em um assembly que não é marcado com o RuntimeCompatibilityAttribute ou que é marcado como RuntimeCompatibility (WrapNonExceptionThrows = false) contém um bloco de captura que trata System.Exception e não contém um bloco de captura geral imediatamente posterior.|
|[CA2103: examinar segurança obrigatória](../code-quality/ca2103-review-imperative-security.md)|Um método usa segurança obrigatória e pode construir a permissão usando as informações de estado ou os valores de retorno que podem ser alterados enquanto a demanda estiver ativa. Use a segurança declarativa sempre que possível.|
|[CA2104: não declarar tipos de referência mutáveis somente leitura](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md)|Um tipo visível externamente contém um campo somente leitura visível externamente que é um tipo de referência mutável. Um tipo mutável é um tipo cujos dados da instância podem ser modificados.|
|[CA2105: campos de matriz não devem ser somente leitura](../code-quality/ca2105-array-fields-should-not-be-read-only.md)|Quando você aplica o modificador de somente leitura (ReadOnly no Visual Basic) a um campo que contém uma matriz, o campo não pode ser alterado para fazer referência a uma matriz diferente. No entanto, os elementos da matriz armazenados em um campo somente leitura podem ser alterados.|
|[CA2106: declarações seguras](../code-quality/ca2106-secure-asserts.md)|Um método declara uma permissão e nenhuma verificação de segurança é realizada no chamador. A declaração de uma permissão de segurança sem realizar verificações de segurança pode deixar uma fraqueza de segurança explorável no código.|
|[CA2107: examinar o uso de deny e permit only](../code-quality/ca2107-review-deny-and-permit-only-usage.md)|Usando o método PermitOnly e as ações de segurança CodeAccessPermission.Deny só devem ser usados por pessoas com conhecimento avançado de segurança do .NET Framework. O código que usa essas ações de segurança deve passar por uma revisão de segurança.|
|[CA2108: examinar segurança declarativa em tipos de valor](../code-quality/ca2108-review-declarative-security-on-value-types.md)|Um tipo de valor público ou protegido é resguardado por acesso a dados ou exigências de vínculo.|
|[CA2109: examinar manipuladores de eventos visíveis](../code-quality/ca2109-review-visible-event-handlers.md)|Um método público ou protegido de tratamento de eventos foi detectado. Os métodos de tratamento de eventos não devem ser expostos, a menos que seja absolutamente necessário.|
|[CA2111: os ponteiros não devem estar visíveis](../code-quality/ca2111-pointers-should-not-be-visible.md)|Um ponteiro não é privado, interno ou somente leitura. Um código mal-intencionado pode alterar o valor do ponteiro, permitindo o acesso a locais arbitrários na memória ou causando falhas no aplicativo ou no sistema.|
|[CA2112: os tipos seguros não devem expor campos](../code-quality/ca2112-secured-types-should-not-expose-fields.md)|Um tipo público ou protegido contém campos públicos e é protegido por exigências de vínculo. Se tiver acesso a uma instância de um tipo protegido por uma exigência de vínculo, o código não precisará atender à exigência de vínculo para acessar os campos do tipo.|
|[CA2114: a segurança de método deve ser um superconjunto de tipo](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md)|Um método não deve ter segurança declarativa no nível do método e no nível do tipo para a mesma ação.|
|[CA2115: chamar GC.KeepAlive durante o uso de recursos nativos](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md)|Esta regra detecta erros que podem ocorrer porque um recurso não gerenciado está sendo finalizado, enquanto ainda está sendo usado em código não gerenciado.|
|[CA2116: os métodos APTCA só devem chamar métodos APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e o assembly executar código em outro assembly que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2117: os tipos APTCA só devem estender tipos base APTCA](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e um tipo no assembly for herdado de um tipo que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2118: examinar uso de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md)|SuppressUnmanagedCodeSecurityAttribute altera o comportamento do sistema de segurança padrão para membros que executem código não gerenciado que usa interoperabilidade COM ou invocação da plataforma. Esse atributo é usado principalmente para aumentar o desempenho; no entanto, os ganhos de desempenho acompanham riscos de segurança significativos.|
|[CA2119: métodos para lacrar que atendam a interfaces privadas](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md)|Um tipo público herdável fornece uma implementação de método substituível de uma interface (Friend no Visual Basic) interna. Para corrigir uma violação dessa regra, evite que o método seja substituído fora do assembly.|
|[CA2120: proteger construtores de serialização](../code-quality/ca2120-secure-serialization-constructors.md)|Esse tipo tem um construtor que utiliza um objeto System.Runtime.Serialization.SerializationInfo e um objeto System.Runtime.Serialization.StreamingContext (a assinatura do construtor de serialização). Esse construtor não é protegido por uma verificação de segurança, mas um ou mais dos construtores regulares no tipo são protegidos.|
|[CA2121: os construtores estáticos devem ser privados](../code-quality/ca2121-static-constructors-should-be-private.md)|O sistema chama o construtor estático antes que a primeira instância do tipo seja criada ou que outros membros estáticos sejam referenciados. Se não for privado, um construtor estático poderá ser chamado por um código diferente do sistema. Dependendo das operações realizadas no construtor, isso pode causar um comportamento inesperado.|
|[CA2122: não expor indiretamente métodos com demandas de link](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md)|Um membro público ou protegido tem exigências de vínculo e é chamado por um membro que não realiza nenhuma verificação de segurança. Uma exigência de vínculo verifica as permissões apenas do chamador imediato.|
|[CA2123: as demandas de link de substituição devem ser idênticas à base](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md)|Esta regra compara um método ao método de base, que é uma interface ou um método virtual em outro tipo e, em seguida, compara as exigências de vínculo em cada um. Se essa regra for violada, um chamador mal-intencionado poderá ignorar a exigência de vínculo apenas chamando o método não seguro.|
|[CA2124: encapsular cláusulas finalmente vulneráveis em tentativa externa](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md)|Um método público ou protegido contém um bloco try/finally. O bloco finally aparentemente redefine o estado de segurança não está incluído em um bloco finally.|
|[CA2126: demandas do link de tipo exigem demandas de herança](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md)|Um tipo sem lacre público é protegido com uma exigência de link e tem um método substituível. Nem o tipo nem o método é protegido com uma exigência de herança.|
|[CA2130: as constantes críticas de segurança devem ser transparentes](../code-quality/ca2130-security-critical-constants-should-be-transparent.md)|A imposição de transparência não é imposta para valores constantes porque compiladores têm valores constantes internos de modo que nenhuma pesquisa seja necessária no tempo de execução. Os campos constantes devem ter segurança transparente de forma que os revisores de código não pressuponham que o código transparente não pode acessar a constante.|
|[CA2131: os tipos críticos de segurança podem não participar da equivalência de tipo](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md)|Um tipo participa da equivalência de tipo e o próprio tipo, ou um membro ou campo do tipo, é marcado com o atributo SecurityCriticalAttribute. Esta regra é acionada em qualquer tipo crítico ou em tipos que contenham métodos críticos ou campos que estejam participando da equivalência do tipo. Ao detectar um tipo assim, o CLR não o carrega com um TypeLoadException em tempo de execução. Normalmente, essa regra só é acionada quando usuários implementam equivalência de tipo manualmente, em vez de depender de tlbimp e dos compiladores para fazer a equivalência do tipo.|
|[CA2132: os construtores padrão devem ser pelo menos tão críticos quanto construtores padrão do tipo base](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md)|Os tipos e os membros que têm o SecurityCriticalAttribute não podem ser usados pelo código de aplicativo do Silverlight. Os tipos de segurança crítica e os membros só podem ser usados por código confiável no .NET Framework para a biblioteca de classes do Silverlight. Como uma construção pública ou protegida em uma classe derivada deve ter a mesma transparência maior que sua classe base, uma classe em um aplicativo não pode ser derivada de uma classe marcada como SecurityCritical.|
|[CA2133: os representantes devem ser associados a métodos com transparência consistente](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md)|Esse aviso é acionado em um método que associa um representante que foi marcado com o SecurityCriticalAttribute para um método transparente ou marcado com o SecuritySafeCriticalAttribute. O aviso também é acionado em um método que associa um representante transparente ou de segurança crítica a um método crítico.|
|[CA2134: os métodos devem manter uma transparência consistente durante a substituição dos métodos base](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md)|Essa regra é acionada quando um método marcado com o SecurityCriticalAttribute substitui um método transparente ou marcado com o SecuritySafeCriticalAttribute. A regra também é acionada quando um método transparente ou marcado com o SecuritySafeCriticalAttribute substitui um método marcado com um SecurityCriticalAttribute. A regra é aplicada durante a substituição de um método virtual ou a implementação de uma interface.|
|[CA2135: os assemblies de nível 2 não devem conter LinkDemands](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md)|LinkDemands são preteridos no conjunto de regras de segurança nível 2. Em vez de usar LinkDemands para impor a segurança em tempo de compilação JIT (just-in-time), marque os métodos, os tipos e os campos com o atributo SecurityCriticalAttribute.|
|[CA2136: os membros não devem ter anotações de transparência conflitantes](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Os atributos de transparência são aplicados com base nos elementos de código de escopo maior a elementos de escopo menor. Os atributos de transparência dos elementos de código com escopo maior têm precedência sobre atributos de transparência dos elementos de código contidos no primeiro elemento. Por exemplo, uma classe marcada com o atributo SecurityCriticalAttribute não pode conter um método marcado com o atributo SecuritySafeCriticalAttribute.|
|[CA2137: os métodos transparentes só devem conter o nível de integridade verificável](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md)|Um método contém código não verificável ou retorna um tipo por referência. Esta regra é acionada em tentativas por código transparente de segurança para executar MSIL (Microsoft Intermediate Language) não verificável. Entretanto, a regra não contém um verificador de IL completo e, em vez disso, usa heurística para capturar a maioria das violações de verificação de MSIL.|
|[CA2138: os métodos transparentes não devem chamar métodos com o atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md)|Um método de segurança transparente chama um método marcado com o atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: os métodos transparentes talvez não usem o atributo HandleProcessCorruptingExceptions](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md)|Essa regra é acionada em qualquer método que é transparente e tenta tratar uma exceção usando o atributo HandleProcessCorruptedStateExceptionsAttribute de corrompimento de processo. Uma exceção de corrompimento de processo é uma classificação de exceção do CLR versão 4.0 de exceções, como <xref:System.AccessViolationException>. O atributo HandleProcessCorruptedStateExceptionsAttribute só pode ser usado por métodos de segurança crítica e será ignorado se for aplicado a um método transparente.|
|[CA2140: código transparente não deve fazer referência a itens críticos de segurança](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Métodos que são marcados com SecurityTransparentAttribute chamam membros não públicos marcados como SecurityCritical. Esta regra analisa todos os métodos e tipos em um assembly que é misto transparente e crítico e sinaliza todas as chamadas de código transparente para o código de crítico não público que não são marcadas como SecurityTreatAsSafe.|
|[CA2141: métodos transparentes não devem atender a LinkDemands](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md)|Um método transparente de segurança chama um método em um assembly que não foi marcado com o atributo APTCA (AllowPartiallyTrustedCallersAttribute) ou um método transparente de segurança atende a um LinkDemand para um tipo ou um método.|
|[CA2142: código transparente não deve ser protegido com LinkDemands](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md)|Esta regra é acionada em métodos transparentes que exigem LinkDemands para serem acessados. O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões.|
|[CA2143: métodos transparentes não devem usar demandas de segurança](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md)|O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões. O código transparente de segurança deve usar demandas completas para tomar decisões de segurança e o código crítico de segurança não deve confiar no código transparente para fazer a demanda completa.|
|[CA2144: o código transparente não deve carregar assemblies de matrizes de bytes](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md)|A revisão de segurança para o código transparente não é tão completo quanto a revisão de segurança para o código crítico porque o código transparente não pode realizar ações confidenciais de segurança. Os assemblies carregados a partir de uma matriz de bytes podem não ser observados no código transparente e essa matriz de bytes pode conter código crítico ou código crítico de segurança mais importante, que precisa ser auditado.|
|[CA2145: os métodos transparentes não devem ser decorados com o SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md)|Os métodos decorados com o atributo SuppressUnmanagedCodeSecurityAttribute têm um LinkDemand implícito colocado em qualquer método que o chame. Este LinkDemand requer que o código de chamada seja crítico de segurança. A marcação do método que usa SuppressUnmanagedCodeSecurity com o atributo SecurityCriticalAttribute torna esse requisito mais óbvio para chamadores do método.|
|[CA2146: tipos devem ser pelo menos tão críticos quanto seus tipos base e interfaces](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md)|Esta regra é acionada quando um tipo derivado tem um atributo de transparência de segurança que não é tão crítico quanto seu tipo de base ou interface implementada. Apenas os tipos críticos podem derivar os tipos de base críticos ou implementar interfaces críticos, e apenas os tipos críticos ou de segurança crítica podem derivar dos tipos de base críticos de segurança ou implementar interfaces críticas de segurança.|
|[CA2147: os métodos transparentes talvez não usem declarações de segurança](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Esta regra analisa todos os métodos e tipos em um assembly que seja 100% transparente ou transparente/crítico misto e sinaliza o uso declarativo ou obrigatório de Assert.|
|[CA2149: métodos transparentes não devem chamar código nativo](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md)|Essa regra é acionada em qualquer método transparente chamado diretamente no código nativo, por exemplo, por meio de um P/Invoke. As violações dessa regra resultam em um MethodAccessException no modelo de transparência de nível 2 e uma demanda completa para UnmanagedCode no modelo de transparência de nível 1.|
|[CA2151: campos com tipos críticos devem ser críticos para segurança](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md)|Para usar tipos de segurança crítica, o código que faz referência ao tipo deve ser de segurança crítica ou de segurança crítica segura. Isso será verdadeiro mesmo que a referência seja indireta. Por isso, ter um campo de segurança transparente ou de segurança crítica é enganoso porque o código transparente continuará incapaz de acessar o campo.|
|[Não devem ser seguras declarações P/Invoke ca5122: crítico](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md)|Os métodos são marcados como SecuritySafeCritical quando executam uma operação confidencial de segurança, mas também são seguros para serem usados pelo código transparente. O código transparente jamais pode chamar diretamente o código nativo por meio de um P/Invoke. Por isso, a marcação de um P/Invoke como crítico de segurança não permitirá que o código transparente o chame, e é enganosa na análise de segurança.|
|[CA2153: evitar o tratamento de exceções de estado corrompidas](../code-quality/ca2153-avoid-handling-corrupted-state-exceptions.md)|[Corrompido exceções de estado (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicam que a memória corrupção existe em seu processo. Capturar esses em vez de permitir que o processo falhe pode levar a vulnerabilidades de segurança se um invasor pode colocar uma exploração para a região de memória corrompida.|
|[CA3075: processamento de DTD inseguro](../code-quality/ca3075-insecure-dtd-processing.md)|Se você usar instâncias de DTDProcessing inseguras ou referenciar origens de entidade externa, o analisador pode aceitar a entrada não confiável e divulgar informações confidenciais para invasores.|
|[CA3076: execução de Script XSLT não seguro](../code-quality/ca3076-insecure-xslt-script-execution.md)|Se você executar maneira insegura extensível folhas de estilos XSLT (linguagem) em aplicativos .NET, o processador pode resolver referências URI não confiáveis que poderiam revelar informações confidenciais para invasores, levando a negação de serviço e entre sites os ataques.|
|[CA3077: processamento inseguro no design de API, documento XML e leitor de texto XML](../code-quality/ca3077-insecure-processing-in-api-design-xml-document-and-xml-text-reader.md)|Quando a criação de uma API deriva do XMLDocument e XMLTextReader, lembre-se de DtdProcessing.  Usando instâncias de DTDProcessing inseguras ao referenciar ou resolvendo origens de entidade externa ou definir os valores inseguros em XML pode levar à divulgação de informações.|
|[CA3147: Manipuladores de verbo marca com ValidateAntiForgeryToken](../code-quality/ca3147-mark-verb-handlers-with-validateantiforgerytoken.md)|Durante a criação de um controlador ASP.NET MVC, lembre-se de ataques de falsificação de solicitação entre sites. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado ao seu controlador ASP.NET MVC.|