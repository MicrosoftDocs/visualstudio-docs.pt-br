---
title: Avisos de segurança
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 52ddee2e876576508573fbadedcc407f81703e18
ms.sourcegitcommit: 9f6f63a2d76c6e579b4b67a96ec86faba99ad1df
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/03/2019
ms.locfileid: "71933125"
---
# <a name="security-warnings"></a>Avisos de segurança

Os avisos de segurança oferecem suporte a bibliotecas e aplicativos mais seguros. Esses avisos ajudam a evitar falhas de segurança em seu programa. Se você desabilitar um desses avisos, você deve marcar claramente a razão no código e também informar o agente de segurança designado para seu projeto de desenvolvimento.

## <a name="in-this-section"></a>Nesta seção

|Regra|Descrição|
|----------|-----------------|
|[CA2100: Examinar as consultas SQL quanto a vulnerabilidades de segurança](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md)|Um método define a propriedade System.Data.IDbCommand.CommandText usando uma cadeia de caracteres criada com base em um argumento da cadeia de caracteres para o método. Esta regra pressupõe que o argumento da cadeia de caracteres contenha a entrada do usuário. Uma cadeia de caracteres de comando SQL criada com base na entrada do usuário é vulnerável a ataques de injeção SQL.|
|[CA2102: Capturar exceções não CLSCompliant em manipuladores gerais](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md)|Um membro em um assembly que não é marcado com o RuntimeCompatibilityAttribute ou que é marcado como RuntimeCompatibility (WrapNonExceptionThrows = false) contém um bloco de captura que trata System.Exception e não contém um bloco de captura geral imediatamente posterior.|
|[CA2103: Examinar a segurança imperativa](../code-quality/ca2103-review-imperative-security.md)|Um método usa segurança obrigatória e pode construir a permissão usando as informações de estado ou os valores de retorno que podem ser alterados enquanto a demanda estiver ativa. Use a segurança declarativa sempre que possível.|
|[CA2104: Não declarar tipos de referência mutáveis somente leitura](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md)|Um tipo visível externamente contém um campo somente leitura visível externamente que é um tipo de referência mutável. Um tipo mutável é um tipo cujos dados da instância podem ser modificados.|
|[CA2105: Os campos de matriz não devem ser somente leitura](../code-quality/ca2105-array-fields-should-not-be-read-only.md)|Quando você aplica o modificador somente leitura (ReadOnly no Visual Basic) a um campo que contém uma matriz, o campo não pode ser alterado para fazer referência a uma matriz diferente. No entanto, os elementos da matriz armazenados em um campo somente leitura podem ser alterados.|
|[CA2106: Declarações seguras](../code-quality/ca2106-secure-asserts.md)|Um método declara uma permissão e nenhuma verificação de segurança é realizada no chamador. A declaração de uma permissão de segurança sem realizar verificações de segurança pode deixar uma fraqueza de segurança explorável no código.|
|[CA2107: Examinar somente negar e permitir o uso](../code-quality/ca2107-review-deny-and-permit-only-usage.md)|Usar o método PermitOnly e as ações de segurança CodeAccessPermission. Deny devem ser usados somente por aqueles com conhecimento avançado de segurança do .NET. O código que usa essas ações de segurança deve passar por uma revisão de segurança.|
|[CA2108: Examinar a segurança declarativa em tipos de valor](../code-quality/ca2108-review-declarative-security-on-value-types.md)|Um tipo de valor público ou protegido é resguardado por acesso a dados ou exigências de vínculo.|
|[CA2109: Examinar os manipuladores de eventos visíveis](../code-quality/ca2109-review-visible-event-handlers.md)|Um método público ou protegido de tratamento de eventos foi detectado. Os métodos de tratamento de eventos não devem ser expostos, a menos que seja absolutamente necessário.|
|[CA2111: Os ponteiros não devem estar visíveis](../code-quality/ca2111-pointers-should-not-be-visible.md)|Um ponteiro não é privado, interno ou somente leitura. Um código mal-intencionado pode alterar o valor do ponteiro, permitindo o acesso a locais arbitrários na memória ou causando falhas no aplicativo ou no sistema.|
|[CA2112: Tipos protegidos não devem expor campos](../code-quality/ca2112-secured-types-should-not-expose-fields.md)|Um tipo público ou protegido contém campos públicos e é protegido por exigências de vínculo. Se tiver acesso a uma instância de um tipo protegido por uma exigência de vínculo, o código não precisará atender à exigência de vínculo para acessar os campos do tipo.|
|[CA2114: A segurança do método deve ser um superconjunto do tipo](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md)|Um método não deve ter segurança declarativa no nível do método e no nível do tipo para a mesma ação.|
|[CA2115: Chame GC. KeepAlive ao usar recursos nativos](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md)|Esta regra detecta erros que podem ocorrer porque um recurso não gerenciado está sendo finalizado, enquanto ainda está sendo usado em código não gerenciado.|
|[CA2116: Os métodos APTCA só devem chamar métodos APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e o assembly executar código em outro assembly que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2117: Os tipos APTCA só devem estender os tipos base APTCA](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e um tipo no assembly for herdado de um tipo que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2118: Examinar o uso do SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md)|SuppressUnmanagedCodeSecurityAttribute altera o comportamento do sistema de segurança padrão para membros que executem código não gerenciado que usa interoperabilidade COM ou invocação da plataforma. Esse atributo é usado principalmente para aumentar o desempenho; no entanto, os ganhos de desempenho acompanham riscos de segurança significativos.|
|[CA2119: Métodos de lacre que atendem a interfaces privadas](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md)|Um tipo público herdável fornece uma implementação de método substituível de uma interface interna (Friend no Visual Basic). Para corrigir uma violação dessa regra, evite que o método seja substituído fora do assembly.|
|[CA2120: Construtores de serialização segura](../code-quality/ca2120-secure-serialization-constructors.md)|Esse tipo tem um construtor que utiliza um objeto System.Runtime.Serialization.SerializationInfo e um objeto System.Runtime.Serialization.StreamingContext (a assinatura do construtor de serialização). Esse construtor não é protegido por uma verificação de segurança, mas um ou mais dos construtores regulares no tipo são protegidos.|
|[CA2121: Construtores estáticos devem ser particulares](../code-quality/ca2121-static-constructors-should-be-private.md)|O sistema chama o construtor estático antes que a primeira instância do tipo seja criada ou que outros membros estáticos sejam referenciados. Se não for privado, um construtor estático poderá ser chamado por um código diferente do sistema. Dependendo das operações realizadas no construtor, isso pode causar um comportamento inesperado.|
|[CA2122: Não expor indiretamente métodos com demandas de link](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md)|Um membro público ou protegido tem exigências de vínculo e é chamado por um membro que não realiza nenhuma verificação de segurança. Uma exigência de vínculo verifica as permissões apenas do chamador imediato.|
|[CA2123: A substituição das demandas de link deve ser idêntica à base](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md)|Esta regra compara um método ao método de base, que é uma interface ou um método virtual em outro tipo e, em seguida, compara as exigências de vínculo em cada um. Se essa regra for violada, um chamador mal-intencionado poderá ignorar a exigência de vínculo apenas chamando o método não seguro.|
|[CA2124: Encapsular cláusulas finally vulneráveis na tentativa externa](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md)|Um método público ou protegido contém um bloco try/finally. O bloco finally aparentemente redefine o estado de segurança não está incluído em um bloco finally.|
|[CA2126: Solicitações de link de tipo exigem demandas de herança](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md)|Um tipo sem lacre público é protegido com uma exigência de link e tem um método substituível. Nem o tipo nem o método é protegido com uma exigência de herança.|
|[CA2130: As constantes críticas de segurança devem ser transparentes](../code-quality/ca2130-security-critical-constants-should-be-transparent.md)|A imposição de transparência não é imposta para valores constantes porque compiladores têm valores constantes internos de modo que nenhuma pesquisa seja necessária no tempo de execução. Os campos constantes devem ter segurança transparente de forma que os revisores de código não pressuponham que o código transparente não pode acessar a constante.|
|[CA2131: Tipos críticos de segurança podem não participar de equivalência de tipo](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md)|Um tipo participa da equivalência de tipo e o próprio tipo, ou um membro ou campo do tipo, é marcado com o atributo SecurityCriticalAttribute. Esta regra é acionada em qualquer tipo crítico ou em tipos que contenham métodos críticos ou campos que estejam participando da equivalência do tipo. Ao detectar um tipo assim, o CLR não o carrega com um TypeLoadException em tempo de execução. Normalmente, essa regra só é acionada quando usuários implementam equivalência de tipo manualmente, em vez de depender de tlbimp e dos compiladores para fazer a equivalência do tipo.|
|[CA2132: Os construtores padrão devem ser pelo menos tão críticos quanto os construtores padrão de tipo base](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md)|Os tipos e os membros que têm o SecurityCriticalAttribute não podem ser usados pelo código de aplicativo do Silverlight. Os tipos de segurança crítica e os membros só podem ser usados por código confiável no .NET Framework para a biblioteca de classes do Silverlight. Como uma construção pública ou protegida em uma classe derivada deve ter a mesma transparência maior que sua classe base, uma classe em um aplicativo não pode ser derivada de uma classe marcada como SecurityCritical.|
|[CA2133: Delegados devem ser associados a métodos com transparência consistente](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md)|Esse aviso é acionado em um método que associa um representante que foi marcado com o SecurityCriticalAttribute para um método transparente ou marcado com o SecuritySafeCriticalAttribute. O aviso também é acionado em um método que associa um representante transparente ou de segurança crítica a um método crítico.|
|[CA2134: Os métodos devem manter a transparência consistente ao substituir os métodos base](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md)|Essa regra é acionada quando um método marcado com o SecurityCriticalAttribute substitui um método transparente ou marcado com o SecuritySafeCriticalAttribute. A regra também é acionada quando um método transparente ou marcado com o SecuritySafeCriticalAttribute substitui um método marcado com um SecurityCriticalAttribute. A regra é aplicada durante a substituição de um método virtual ou a implementação de uma interface.|
|[CA2135: Os assemblies de nível 2 não devem conter LinkDemands](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md)|LinkDemands são preteridos no conjunto de regras de segurança nível 2. Em vez de usar LinkDemands para impor a segurança em tempo de compilação JIT (just-in-time), marque os métodos, os tipos e os campos com o atributo SecurityCriticalAttribute.|
|[CA2136: Os membros não devem ter anotações de transparência conflitantes](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Os atributos de transparência são aplicados com base nos elementos de código de escopo maior a elementos de escopo menor. Os atributos de transparência dos elementos de código com escopo maior têm precedência sobre atributos de transparência dos elementos de código contidos no primeiro elemento. Por exemplo, uma classe marcada com o atributo SecurityCriticalAttribute não pode conter um método marcado com o atributo SecuritySafeCriticalAttribute.|
|[CA2137: Os métodos Transparent devem conter somente IL verificável](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md)|Um método contém código não verificável ou retorna um tipo por referência. Esta regra é acionada em tentativas por código transparente de segurança para executar MSIL (Microsoft Intermediate Language) não verificável. Entretanto, a regra não contém um verificador de IL completo e, em vez disso, usa heurística para capturar a maioria das violações de verificação de MSIL.|
|[CA2138: Métodos Transparent não devem chamar métodos com o atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md)|Um método de segurança transparente chama um método marcado com o atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Métodos transparentes não podem usar o atributo HandleProcessCorruptingExceptions](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md)|Essa regra é acionada em qualquer método transparente e tenta manipular um processo que corrompe a exceção usando o atributo HandleProcessCorruptedStateExceptionsAttribute. Uma exceção de dano do processo é uma classificação de exceção do CLR versão 4,0 de exceções como <xref:System.AccessViolationException>. O atributo HandleProcessCorruptedStateExceptionsAttribute só pode ser usado por métodos de segurança crítica e será ignorado se for aplicado a um método transparente.|
|[CA2140: O código transparent não deve fazer referência a itens críticos de segurança](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Métodos que são marcados com SecurityTransparentAttribute chamam membros não públicos marcados como SecurityCritical. Essa regra analisa todos os métodos e tipos em um assembly misto transparente e crítico e sinaliza todas as chamadas do código Transparent para um código crítico não público que não esteja marcado como SecurityTreatAsSafe.|
|[CA2141: métodos transparentes não devem atender a LinkDemands](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md)|Um método transparente de segurança chama um método em um assembly que não foi marcado com o atributo APTCA (AllowPartiallyTrustedCallersAttribute) ou um método transparente de segurança atende a um LinkDemand para um tipo ou um método.|
|[CA2142: O código transparent não deve ser protegido com LinkDemands](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md)|Esta regra é acionada em métodos transparentes que exigem LinkDemands para serem acessados. O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões.|
|[CA2143: Os métodos transparentes não devem usar as demandas de segurança](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md)|O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões. O código transparente de segurança deve usar demandas completas para tomar decisões de segurança e o código crítico de segurança não deve confiar no código transparente para fazer a demanda completa.|
|[CA2144: O código transparent não deve carregar assemblies de matrizes de bytes](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md)|A revisão de segurança para o código transparente não é tão completo quanto a revisão de segurança para o código crítico porque o código transparente não pode realizar ações confidenciais de segurança. Os assemblies carregados a partir de uma matriz de bytes podem não ser observados no código transparente e essa matriz de bytes pode conter código crítico ou código crítico de segurança mais importante, que precisa ser auditado.|
|[CA2145: Métodos transparentes não devem ser decorados com o SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md)|Os métodos decorados com o atributo SuppressUnmanagedCodeSecurityAttribute têm um LinkDemand implícito colocado em qualquer método que o chame. Este LinkDemand requer que o código de chamada seja crítico de segurança. A marcação do método que usa SuppressUnmanagedCodeSecurity com o atributo SecurityCriticalAttribute torna esse requisito mais óbvio para chamadores do método.|
|[CA2146: Os tipos devem ser, pelo menos, tão críticos quanto seus tipos de base e interfaces](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md)|Esta regra é acionada quando um tipo derivado tem um atributo de transparência de segurança que não é tão crítico quanto seu tipo de base ou interface implementada. Apenas os tipos críticos podem derivar os tipos de base críticos ou implementar interfaces críticos, e apenas os tipos críticos ou de segurança crítica podem derivar dos tipos de base críticos de segurança ou implementar interfaces críticas de segurança.|
|[CA2147: Métodos transparentes não podem usar declarações de segurança](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Esta regra analisa todos os métodos e tipos em um assembly que seja 100% transparente ou transparente/crítico misto e sinaliza o uso declarativo ou obrigatório de Assert.|
|[CA2149: Métodos transparentes não devem chamar código nativo](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md)|Essa regra é acionada em qualquer método transparente que chama diretamente em código nativo, por exemplo, por meio de um P/Invoke. As violações dessa regra resultam em um MethodAccessException no modelo de transparência de nível 2 e uma demanda completa para UnmanagedCode no modelo de transparência de nível 1.|
|[CA2151: Os campos com tipos críticos devem ser críticos para segurança](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md)|Para usar tipos de segurança crítica, o código que faz referência ao tipo deve ser de segurança crítica ou de segurança crítica segura. Isso será verdadeiro mesmo que a referência seja indireta. Por isso, ter um campo de segurança transparente ou de segurança crítica é enganoso porque o código transparente continuará incapaz de acessar o campo.|
|[CA5122: as declarações de P-Invoke não devem ser críticas para segurança](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md)|Os métodos são marcados como SecuritySafeCritical quando executam uma operação confidencial de segurança, mas também são seguros para serem usados pelo código transparente. O código transparente jamais pode chamar diretamente o código nativo por meio de um P/Invoke. Por isso, a marcação de um P/Invoke como crítico de segurança não permitirá que o código transparente o chame, e é enganosa na análise de segurança.|
|[CA2153: Evite manipular exceções de estado corrompidas @ no__t-0|As [exceções de estado corrompidas (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicam que há corrupção de memória em seu processo. A captura deles, em vez de permitir que o processo falhe, pode levar a vulnerabilidades de segurança se um invasor puder fazer uma exploração na região de memória corrompida.|
|[CA3075: Processamento de DTD não seguro @ no__t-0|Se você usar instâncias DTDProcessing inseguras ou referenciar fontes externas de entidade, o analisador poderá aceitar entrada não confiável e divulgar informações confidenciais a invasores.|
|[CA3076: Execução de script XSLT não segura @ no__t-0|Se você executar as transformações de linguagem de folhas de estilos extensível (XSLT) em aplicativos .NET de forma insegura, o processador poderá resolver referências de URI não confiáveis que poderiam divulgar informações confidenciais a invasores, levando à negação de serviço e a sites verdadeiros.|
|[CA3077: Processamento inseguro em design de API, documento XML e leitor de texto XML @ no__t-0|Ao criar uma API derivada de XMLDocument e XMLTextReader, lembre-se de DtdProcessing. Usar instâncias DTDProcessing inseguras ao referenciar ou resolver fontes de entidade externas ou definir valores inseguros no XML pode levar à divulgação de informações.|
|[CA3147: Marcar manipuladores de verbo com ValidateAntiForgeryToken @ no__t-0|Ao criar um controlador MVC ASP.NET, lembre-se de ataques de solicitação entre sites forjado. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para o controlador MVC ASP.NET.|
|[CA5361: Não desabilitar o uso do SChannel de criptografia forte @ no__t-0|A `Switch.System.Net.DontEnableSchUseStrongCrypto` configuração `true` para enfraquece a criptografia usada em conexões TLS (segurança da camada de transporte) de saída. A criptografia mais fraca pode comprometer a confidencialidade da comunicação entre o aplicativo e o servidor, tornando mais fácil para os invasores bisbilhotarem dados confidenciais.|
|[CA5363: Não desabilitar a validação de solicitação @ no__t-0|A validação de solicitação é um recurso no ASP.NET que examina as solicitações HTTP e determina se elas contêm conteúdo potencialmente perigoso que pode levar a ataques de injeção, incluindo scripts entre sites.|
|[CA5364: Não usar protocolos de segurança preteridos](../code-quality/ca5364.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5369: Usar XmlReader para desserializar @ no__t-0|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas, que devem ser restringidas com o uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5370: Usar XmlReader para validar o leitor @ no__t-0|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. Esse carregamento perigoso pode ser restringido usando um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5371: Usar XmlReader para leitura de esquema @ no__t-0|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. O uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado restringe isso.|
|[CA5372: Usar XmlReader para XPathDocument @ no__t-0|O processamento de XML de dados não confiáveis pode carregar referências externas perigosas, que podem ser restringidas usando um XmlReader com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5373: Não use a função de derivação de chave obsoleta @ no__t-0|Essa regra detecta a invocação de métodos <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> de derivação de chave fraca e. `Rfc2898DeriveBytes.CryptDeriveKey` <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>usou um algoritmo fraco de PBKDF1.|
|[CA5378: Não desabilitar ServicePointManagerSecurityProtocols @ no__t-0|Configuração `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` para`true` limita as conexões de TLS (segurança de camada de transporte) do Windows Communication Framework (WCF) usando o TLS 1,0. Essa versão do TLS será preterida.|
|[CA5380: Não adicionar certificados ao repositório raiz @ no__t-0|Essa regra detecta o código que adiciona um certificado ao repositório de certificados das autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs públicas que atendem aos requisitos do programa de certificado raiz da Microsoft.|
|[CA5381: Certifique-se de que os certificados não sejam adicionados ao repositório raiz @ no__t-0|Essa regra detecta o código que potencialmente adiciona um certificado ao repositório de certificados de autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs (autoridades de certificação) públicas que atendem aos requisitos do Microsoft Root Certificate Program.|
|[CA5386: Evite codificar o valor de SecurityProtocolType](../code-quality/ca5386.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo e ter como destino pelo menos .NET Framework v 4.7.1.|
|[CA5389: Não adicione o caminho do item de arquivamento ao caminho do sistema de arquivos de destino @ no__t-0|O caminho do arquivo pode ser relativo e pode levar ao acesso do sistema de arquivos fora do caminho de destino do sistema de arquivos esperado, levando a alterações de configuração mal-intencionadas e à execução remota de código por meio da técnica de Lay-and-wait.|
|[CA5397: Não usar valores de SslProtocols preteridos](../code-quality/ca5397.md)|o TLS (ransport Layer Security) protege a comunicação entre computadores, mais comumente com o protocolo HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5398: Evitar valores de SslProtocols codificados](../code-quality/ca5398.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo.|
