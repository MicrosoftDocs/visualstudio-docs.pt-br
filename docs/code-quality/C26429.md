---
title: C26429
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26429
helpviewer_keywords:
- C26429
ms.assetid: 4e1c74d5-7307-436c-927b-f74ae863282c
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 5a9e69f238f8dba8193022a415dce3c54a9e6d94
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011516"
---
# <a name="c26429-use_notnull"></a>C26429 USE_NOTNULL

"O símbolo nunca é testado quanto à nulidade, pode ser marcado como GSL:: NOT_NULL."

**C++ Principais diretrizes**: L. 23: Use uma > NOT_NULL @ no__t-0T para indicar que "NULL" não é um valor válido

É uma prática comum usar declarações para impor suposições sobre a validade de valores de ponteiro. O problema com declarações é que elas não expõem suposições por meio da interface (por exemplo, em tipos de retorno ou parâmetros). As declarações também são mais difíceis de manter e manter em sincronia com outras alterações de código. A recomendação é usar GSL:: NOT_NULL da biblioteca de suporte de diretrizes como um marcador de recursos que nunca deve ter um valor nulo. A regra USE_NOTNULL ajuda a identificar locais que omitem verificações de nulidade e, portanto, podem ser atualizadas para usar GSL:: NOT_NULL.

## <a name="remarks"></a>Comentários

- A lógica da regra requer que o código desfaça referência a uma variável de ponteiro para que a verificação de nulidade (ou imposição de valor não nulo) seja justificada. Portanto, o aviso será emitido somente se os ponteiros forem desreferenciados e nunca forem testados quanto à nulidade.
  - A implementação atual lida apenas com ponteiros simples (ou seus aliases) e não detecta ponteiros inteligentes, embora GSL:: NOT_NULL também possa ser aplicado a ponteiros inteligentes.
  - Uma variável é marcada como verificada quanto à nulidade quando usada nos seguintes contextos:
  - como uma expressão de símbolo em uma condição de ramificação, por exemplo, "if (p) {...}";
  - operações lógicas que não são de não-bit;
  - operações de comparação em que um operando é uma expressão constante que é avaliada como zero.
  - A regra não tem rastreamento completo de fluxo de alterações e pode produzir resultados incorretos em casos em que são usadas verificações indiretas (por exemplo, quando a variável intermediária mantém um valor nulo e posteriormente usada em comparação).

## <a name="example"></a>Exemplo

expectativa oculta

```cpp
using client_collection = gsl::span<client*>;
// ...
void keep_alive(const connection *connection)   // C26429
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];               // C26429
        client->send_heartbeat();
        // ...
    }
}
```

expectativa oculta – esclarecida por GSL:: NOT_NULL

```cpp
using client_collection = gsl::span<gsl::not_null<client*>>;
// ...
void keep_alive(gsl::not_null<const connection*> connection)
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];
        client->send_heartbeat();
        // ...
    }
}
```
