---
title: Avisos de segurança
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 004f10600df3ed2f9c1f62557e0915638482877e
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/01/2020
ms.locfileid: "75587206"
---
# <a name="security-warnings"></a>Avisos de segurança

Os avisos de segurança oferecem suporte a bibliotecas e aplicativos mais seguros. Esses avisos ajudam a evitar falhas de segurança em seu programa. Se você desabilitar um desses avisos, você deve marcar claramente a razão no código e também informar o agente de segurança designado para seu projeto de desenvolvimento.

## <a name="in-this-section"></a>Nesta seção

|Regra|Descrição|
|----------|-----------------|
|[CA2100: examinar consultas SQL para vulnerabilidades de segurança](../code-quality/ca2100.md)|Um método define a propriedade System.Data.IDbCommand.CommandText usando uma cadeia de caracteres criada com base em um argumento da cadeia de caracteres para o método. Esta regra pressupõe que o argumento da cadeia de caracteres contenha a entrada do usuário. Uma cadeia de caracteres de comando SQL criada com base na entrada do usuário é vulnerável a ataques de injeção SQL.|
|[CA2102: capturar exceções que não sejam CLSCompliant em manipuladores gerais](../code-quality/ca2102.md)|Um membro em um assembly que não é marcado com o RuntimeCompatibilityAttribute ou que é marcado como RuntimeCompatibility (WrapNonExceptionThrows = false) contém um bloco de captura que trata System.Exception e não contém um bloco de captura geral imediatamente posterior.|
|[CA2103: examinar segurança obrigatória](../code-quality/ca2103.md)|Um método usa segurança obrigatória e pode construir a permissão usando as informações de estado ou os valores de retorno que podem ser alterados enquanto a demanda estiver ativa. Use a segurança declarativa sempre que possível.|
|[CA2104: não declarar tipos de referência mutáveis somente leitura](../code-quality/ca2104.md)|Um tipo visível externamente contém um campo somente leitura visível externamente que é um tipo de referência mutável. Um tipo mutável é um tipo cujos dados da instância podem ser modificados.|
|[CA2105: campos de matriz não devem ser somente leitura](../code-quality/ca2105.md)|Quando você aplica o modificador somente leitura (ReadOnly no Visual Basic) a um campo que contém uma matriz, o campo não pode ser alterado para fazer referência a uma matriz diferente. No entanto, os elementos da matriz armazenados em um campo somente leitura podem ser alterados.|
|[CA2106: declarações seguras](../code-quality/ca2106.md)|Um método declara uma permissão e nenhuma verificação de segurança é realizada no chamador. A declaração de uma permissão de segurança sem realizar verificações de segurança pode deixar uma fraqueza de segurança explorável no código.|
|[CA2107: examinar o uso de deny e permit only](../code-quality/ca2107.md)|Usar o método PermitOnly e as ações de segurança CodeAccessPermission. Deny devem ser usados somente por aqueles com conhecimento avançado de segurança do .NET. O código que usa essas ações de segurança deve passar por uma revisão de segurança.|
|[CA2108: examinar segurança declarativa em tipos de valor](../code-quality/ca2108.md)|Um tipo de valor público ou protegido é resguardado por acesso a dados ou exigências de vínculo.|
|[CA2109: examinar manipuladores de eventos visíveis](../code-quality/ca2109.md)|Um método público ou protegido de tratamento de eventos foi detectado. Os métodos de tratamento de eventos não devem ser expostos, a menos que seja absolutamente necessário.|
|[CA2111: os ponteiros não devem estar visíveis](../code-quality/ca2111.md)|Um ponteiro não é privado, interno ou somente leitura. Um código mal-intencionado pode alterar o valor do ponteiro, permitindo o acesso a locais arbitrários na memória ou causando falhas no aplicativo ou no sistema.|
|[CA2112: os tipos seguros não devem expor campos](../code-quality/ca2112.md)|Um tipo público ou protegido contém campos públicos e é protegido por exigências de vínculo. Se tiver acesso a uma instância de um tipo protegido por uma exigência de vínculo, o código não precisará atender à exigência de vínculo para acessar os campos do tipo.|
|[CA2114: a segurança de método deve ser um superconjunto de tipo](../code-quality/ca2114.md)|Um método não deve ter segurança declarativa no nível do método e no nível do tipo para a mesma ação.|
|[CA2115: chamar GC.KeepAlive durante o uso de recursos nativos](../code-quality/ca2115.md)|Esta regra detecta erros que podem ocorrer porque um recurso não gerenciado está sendo finalizado, enquanto ainda está sendo usado em código não gerenciado.|
|[CA2116: os métodos APTCA só devem chamar métodos APTCA](../code-quality/ca2116.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e o assembly executar código em outro assembly que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2117: os tipos APTCA só devem estender tipos base APTCA](../code-quality/ca2117.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e um tipo no assembly for herdado de um tipo que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2118: examinar uso de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute altera o comportamento do sistema de segurança padrão para membros que executem código não gerenciado que usa interoperabilidade COM ou invocação da plataforma. Esse atributo é usado principalmente para aumentar o desempenho; no entanto, os ganhos de desempenho acompanham riscos de segurança significativos.|
|[CA2119: métodos para lacrar que atendam a interfaces privadas](../code-quality/ca2119.md)|Um tipo público herdável fornece uma implementação de método substituível de uma interface interna (Friend no Visual Basic). Para corrigir uma violação dessa regra, evite que o método seja substituído fora do assembly.|
|[CA2120: proteger construtores de serialização](../code-quality/ca2120.md)|Esse tipo tem um construtor que utiliza um objeto System.Runtime.Serialization.SerializationInfo e um objeto System.Runtime.Serialization.StreamingContext (a assinatura do construtor de serialização). Esse construtor não é protegido por uma verificação de segurança, mas um ou mais dos construtores regulares no tipo são protegidos.|
|[CA2121: os construtores estáticos devem ser privados](../code-quality/ca2121.md)|O sistema chama o construtor estático antes que a primeira instância do tipo seja criada ou que outros membros estáticos sejam referenciados. Se não for privado, um construtor estático poderá ser chamado por um código diferente do sistema. Dependendo das operações realizadas no construtor, isso pode causar um comportamento inesperado.|
|[CA2122: não expor indiretamente métodos com demandas de link](../code-quality/ca2122.md)|Um membro público ou protegido tem exigências de vínculo e é chamado por um membro que não realiza nenhuma verificação de segurança. Uma exigência de vínculo verifica as permissões apenas do chamador imediato.|
|[CA2123: as demandas de link de substituição devem ser idênticas à base](../code-quality/ca2123.md)|Esta regra compara um método ao método de base, que é uma interface ou um método virtual em outro tipo e, em seguida, compara as exigências de vínculo em cada um. Se essa regra for violada, um chamador mal-intencionado poderá ignorar a exigência de vínculo apenas chamando o método não seguro.|
|[CA2124: encapsular cláusulas finalmente vulneráveis em tentativa externa](../code-quality/ca2124.md)|Um método público ou protegido contém um bloco try/finally. O bloco finally aparentemente redefine o estado de segurança não está incluído em um bloco finally.|
|[CA2126: demandas do link de tipo exigem demandas de herança](../code-quality/ca2126.md)|Um tipo sem lacre público é protegido com uma exigência de link e tem um método substituível. Nem o tipo nem o método é protegido com uma exigência de herança.|
|[CA2130: as constantes críticas de segurança devem ser transparentes](../code-quality/ca2130.md)|A imposição de transparência não é imposta para valores constantes porque compiladores têm valores constantes internos de modo que nenhuma pesquisa seja necessária no tempo de execução. Os campos constantes devem ter segurança transparente de forma que os revisores de código não pressuponham que o código transparente não pode acessar a constante.|
|[CA2131: os tipos críticos de segurança podem não participar da equivalência de tipo](../code-quality/ca2131.md)|Um tipo participa da equivalência de tipo e o próprio tipo, ou um membro ou campo do tipo, é marcado com o atributo SecurityCriticalAttribute. Esta regra é acionada em qualquer tipo crítico ou em tipos que contenham métodos críticos ou campos que estejam participando da equivalência do tipo. Ao detectar um tipo assim, o CLR não o carrega com um TypeLoadException em tempo de execução. Normalmente, essa regra só é acionada quando usuários implementam equivalência de tipo manualmente, em vez de depender de tlbimp e dos compiladores para fazer a equivalência do tipo.|
|[CA2132: os construtores padrão devem ser pelo menos tão críticos quanto construtores padrão do tipo base](../code-quality/ca2132.md)|Os tipos e os membros que têm o SecurityCriticalAttribute não podem ser usados pelo código de aplicativo do Silverlight. Os tipos de segurança crítica e os membros só podem ser usados por código confiável no .NET Framework para a biblioteca de classes do Silverlight. Como uma construção pública ou protegida em uma classe derivada deve ter a mesma transparência maior que sua classe base, uma classe em um aplicativo não pode ser derivada de uma classe marcada como SecurityCritical.|
|[CA2133: os representantes devem ser associados a métodos com transparência consistente](../code-quality/ca2133.md)|Esse aviso é acionado em um método que associa um representante que foi marcado com o SecurityCriticalAttribute para um método transparente ou marcado com o SecuritySafeCriticalAttribute. O aviso também é acionado em um método que associa um representante transparente ou de segurança crítica a um método crítico.|
|[CA2134: os métodos devem manter uma transparência consistente durante a substituição dos métodos base](../code-quality/ca2134.md)|Essa regra é acionada quando um método marcado com o SecurityCriticalAttribute substitui um método transparente ou marcado com o SecuritySafeCriticalAttribute. A regra também é acionada quando um método transparente ou marcado com o SecuritySafeCriticalAttribute substitui um método marcado com um SecurityCriticalAttribute. A regra é aplicada durante a substituição de um método virtual ou a implementação de uma interface.|
|[CA2135: os assemblies de nível 2 não devem conter LinkDemands](../code-quality/ca2135.md)|LinkDemands são preteridos no conjunto de regras de segurança nível 2. Em vez de usar LinkDemands para impor a segurança em tempo de compilação JIT (just-in-time), marque os métodos, os tipos e os campos com o atributo SecurityCriticalAttribute.|
|[CA2136: os membros não devem ter anotações de transparência conflitantes](../code-quality/ca2136.md)|Os atributos de transparência são aplicados com base nos elementos de código de escopo maior a elementos de escopo menor. Os atributos de transparência dos elementos de código com escopo maior têm precedência sobre atributos de transparência dos elementos de código contidos no primeiro elemento. Por exemplo, uma classe marcada com o atributo SecurityCriticalAttribute não pode conter um método marcado com o atributo SecuritySafeCriticalAttribute.|
|[CA2137: os métodos transparentes só devem conter o nível de integridade verificável](../code-quality/ca2137.md)|Um método contém código não verificável ou retorna um tipo por referência. Esta regra é acionada em tentativas por código transparente de segurança para executar MSIL (Microsoft Intermediate Language) não verificável. Entretanto, a regra não contém um verificador de IL completo e, em vez disso, usa heurística para capturar a maioria das violações de verificação de MSIL.|
|[CA2138: os métodos transparentes não devem chamar métodos com o atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Um método de segurança transparente chama um método marcado com o atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: os métodos transparentes talvez não usem o atributo HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Essa regra é acionada em qualquer método transparente e tenta manipular um processo que corrompe a exceção usando o atributo HandleProcessCorruptedStateExceptionsAttribute. Uma exceção de dano do processo é uma classificação de exceção do CLR versão 4,0 de exceções como <xref:System.AccessViolationException>. O atributo HandleProcessCorruptedStateExceptionsAttribute só pode ser usado por métodos de segurança crítica e será ignorado se for aplicado a um método transparente.|
|[CA2140: código transparente não deve fazer referência a itens críticos de segurança](../code-quality/ca2140.md)|Métodos que são marcados com SecurityTransparentAttribute chamam membros não públicos marcados como SecurityCritical. Essa regra analisa todos os métodos e tipos em um assembly misto transparente e crítico e sinaliza todas as chamadas do código Transparent para um código crítico não público que não esteja marcado como SecurityTreatAsSafe.|
|[CA2141: métodos transparentes não devem atender a LinkDemands](../code-quality/ca2141.md)|Um método transparente de segurança chama um método em um assembly que não foi marcado com o atributo APTCA (AllowPartiallyTrustedCallersAttribute) ou um método transparente de segurança atende a um LinkDemand para um tipo ou um método.|
|[CA2142: código transparente não deve ser protegido com LinkDemands](../code-quality/ca2142.md)|Esta regra é acionada em métodos transparentes que exigem LinkDemands para serem acessados. O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões.|
|[CA2143: métodos transparentes não devem usar demandas de segurança](../code-quality/ca2143.md)|O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões. O código transparente de segurança deve usar demandas completas para tomar decisões de segurança e o código crítico de segurança não deve confiar no código transparente para fazer a demanda completa.|
|[CA2144: o código transparente não deve carregar assemblies de matrizes de bytes](../code-quality/ca2144.md)|A revisão de segurança para o código transparente não é tão completo quanto a revisão de segurança para o código crítico porque o código transparente não pode realizar ações confidenciais de segurança. Os assemblies carregados a partir de uma matriz de bytes podem não ser observados no código transparente e essa matriz de bytes pode conter código crítico ou código crítico de segurança mais importante, que precisa ser auditado.|
|[CA2145: os métodos transparentes não devem ser decorados com o SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Os métodos decorados com o atributo SuppressUnmanagedCodeSecurityAttribute têm um LinkDemand implícito colocado em qualquer método que o chame. Este LinkDemand requer que o código de chamada seja crítico de segurança. A marcação do método que usa SuppressUnmanagedCodeSecurity com o atributo SecurityCriticalAttribute torna esse requisito mais óbvio para chamadores do método.|
|[CA2146: tipos devem ser pelo menos tão críticos quanto seus tipos base e interfaces](../code-quality/ca2146.md)|Esta regra é acionada quando um tipo derivado tem um atributo de transparência de segurança que não é tão crítico quanto seu tipo de base ou interface implementada. Apenas os tipos críticos podem derivar os tipos de base críticos ou implementar interfaces críticos, e apenas os tipos críticos ou de segurança crítica podem derivar dos tipos de base críticos de segurança ou implementar interfaces críticas de segurança.|
|[CA2147: os métodos transparentes talvez não usem declarações de segurança](../code-quality/ca2147.md)|Esta regra analisa todos os métodos e tipos em um assembly que seja 100% transparente ou transparente/crítico misto e sinaliza o uso declarativo ou obrigatório de Assert.|
|[CA2149: métodos transparentes não devem chamar código nativo](../code-quality/ca2149.md)|Essa regra é acionada em qualquer método transparente que chama diretamente em código nativo, por exemplo, por meio de um P/Invoke. As violações dessa regra resultam em um MethodAccessException no modelo de transparência de nível 2 e uma demanda completa para UnmanagedCode no modelo de transparência de nível 1.|
|[CA2151: campos com tipos críticos devem ser críticos para segurança](../code-quality/ca2151.md)|Para usar tipos de segurança crítica, o código que faz referência ao tipo deve ser de segurança crítica ou de segurança crítica segura. Isso será verdadeiro mesmo que a referência seja indireta. Por isso, ter um campo de segurança transparente ou de segurança crítica é enganoso porque o código transparente continuará incapaz de acessar o campo.|
|[CA2153: evitar o tratamento de exceções de estado corrompidas](../code-quality/ca2153.md)|As [exceções de estado corrompidas (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicam que há corrupção de memória em seu processo. A captura deles, em vez de permitir que o processo falhe, pode levar a vulnerabilidades de segurança se um invasor puder fazer uma exploração na região de memória corrompida.|
|[CA2300: não usar desserializador inseguro BinaryFormatter](../code-quality/ca2300.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2301: não chame BinaryFormatter. desserializate sem primeiro configurar BinaryFormatter. Binder](../code-quality/ca2301.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2302: Certifique-se de que BinaryFormatter. Binder esteja definido antes de chamar BinaryFormatter. desserializar](../code-quality/ca2302.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2305: não usar desserializador inseguro LosFormatter](../code-quality/ca2305.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2310: não usar o NetDataContractSerializer do desserializador inseguro](../code-quality/ca2310.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2311: não desserializar sem primeiro configurar o NetDataContractSerializer. Binder](../code-quality/ca2311.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2312: Verifique se o NetDataContractSerializer. Binder está definido antes de desserializar](../code-quality/ca2312.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2315: não usar desserializador inseguro ObjectStateFormatter](../code-quality/ca2315.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2321: não desserializar com JavaScriptSerializer usando um SimpleTypeResolver](../code-quality/ca2321.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2322: Verifique se o JavaScriptSerializer não foi inicializado com SimpleTypeResolver antes de desserializar](../code-quality/ca2322.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2326: não use valores de TypeNameHandling diferentes de nenhum](../code-quality/ca2326.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2327: não usar JsonSerializerSettings inseguros](../code-quality/ca2327.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2328: Verifique se JsonSerializerSettings é seguro](../code-quality/ca2328.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2329: não desserializar com JsonSerializer usando uma configuração insegura](../code-quality/ca2329.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2330: Verifique se JsonSerializer tem uma configuração segura ao desserializar](../code-quality/ca2330.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA3001: examinar o código para vulnerabilidades de injeção de SQL](../code-quality/ca3001.md)|Ao trabalhar com comandos de entrada e SQL não confiáveis, lembre-se dos ataques de injeção de SQL. Um ataque de injeção de SQL pode executar comandos SQL mal-intencionados, comprometendo a segurança e a integridade do seu aplicativo.|
|[CA3002: examinar o código para vulnerabilidades de XSS](../code-quality/ca3002.md)|Ao trabalhar com entrada não confiável de solicitações da Web, tenha cuidado com ataques XSS (scripts entre sites). Um ataque XSS injeta entrada não confiável em saída HTML bruta, permitindo que o invasor execute scripts mal-intencionados ou modifique conteúdo de forma mal-intencionada em sua página da Web.|
|[CA3003: examinar o código para vulnerabilidades de injeção de caminho de arquivo](../code-quality/ca3003.md)|Ao trabalhar com entrada não confiável de solicitações da Web, lembre-se de usar a entrada controlada pelo usuário ao especificar caminhos para arquivos.|
|[CA3004: examinar o código para vulnerabilidades de divulgação de informações](../code-quality/ca3004.md)|A divulgação de informações de exceção dá aos invasores insights sobre os internos do seu aplicativo, o que pode ajudar os invasores a encontrar outras vulnerabilidades a serem exploradas.|
|[CA3006: examinar o código para vulnerabilidades de injeção de comando de processo](../code-quality/ca3006.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de comando. Um ataque de injeção de comando pode executar comandos mal-intencionados no sistema operacional subjacente, comprometendo a segurança e a integridade do servidor.|
|[CA3007: examinar o código para vulnerabilidades de redirecionamento aberto](../code-quality/ca3007.md)|Ao trabalhar com entrada não confiável, lembre-se de vulnerabilidades de redirecionamento abertas. Um invasor pode explorar uma vulnerabilidade de redirecionamento aberto para usar seu site para dar a aparência de uma URL legítima, mas redirecionar um visitante dessuspeito para um phishing ou outra página da Web mal-intencionada.|
|[CA3008: examinar o código para vulnerabilidades de injeção de XPath](../code-quality/ca3008.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XPath. A construção de consultas XPath usando a entrada não confiável pode permitir que um invasor manipule a consulta de forma mal-intencionada para retornar um resultado indesejado e possivelmente divulgar o conteúdo do XML consultado.|
|[CA3009: examinar o código para vulnerabilidades de injeção de XML](../code-quality/ca3009.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XML.|
|[CA3010: examinar o código para vulnerabilidades de injeção de XAML](../code-quality/ca3010.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção XAML. XAML é uma linguagem de marcação que representa diretamente a instanciação e execução de objetos. Isso significa que os elementos criados em XAML podem interagir com recursos do sistema (por exemplo, acesso à rede e e/s do sistema de arquivos).|
|[CA3011: examinar o código para vulnerabilidades de injeção de DLL](../code-quality/ca3011.md)|Ao trabalhar com uma entrada não confiável, lembre-se de carregar código não confiável. Se o seu aplicativo Web carregar código não confiável, um invasor poderá injetar DLLs mal-intencionadas em seu processo e executar código mal-intencionado.|
|[CA3012: examinar o código para vulnerabilidades de injeção de Regex](../code-quality/ca3012.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de Regex. Um invasor pode usar a injeção de Regex para modificar uma expressão regular de forma mal-intencionada, para fazer com que o Regex coincida com resultados indesejados ou para fazer com que o Regex consuma CPU excessiva, resultando em um ataque de negação de serviço.|
|[CA3061: não adicionar esquema pela URL](../code-quality/ca3061.md)|Não use a sobrecarga não segura do método Add, pois isso pode causar referências externas perigosas.|
|[CA3075: processamento de DTD inseguro](../code-quality/ca3075.md)|Se você usar instâncias DTDProcessing inseguras ou referenciar fontes externas de entidade, o analisador poderá aceitar entrada não confiável e divulgar informações confidenciais a invasores.|
|[CA3076: execução de Script XSLT não seguro](../code-quality/ca3076.md)|Se você executar as transformações de linguagem de folhas de estilos extensível (XSLT) em aplicativos .NET de forma insegura, o processador poderá resolver referências de URI não confiáveis que poderiam divulgar informações confidenciais a invasores, levando à negação de serviço e a sites verdadeiros.|
|[CA3077: processamento inseguro no design de API, documento XML e leitor de texto XML](../code-quality/ca3077.md)|Ao criar uma API derivada de XMLDocument e XMLTextReader, lembre-se de DtdProcessing. Usar instâncias DTDProcessing inseguras ao referenciar ou resolver fontes de entidade externas ou definir valores inseguros no XML pode levar à divulgação de informações.|
|[CA3147: marcar manipuladores de verbo com ValidateAntiForgeryToken](../code-quality/ca3147.md)|Ao criar um controlador MVC ASP.NET, lembre-se de ataques de solicitação entre sites forjado. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para o controlador MVC ASP.NET.|
|[CA5122: as declarações de P-Invoke não devem ser críticas para segurança](../code-quality/ca5122.md)|Os métodos são marcados como SecuritySafeCritical quando executam uma operação confidencial de segurança, mas também são seguros para serem usados pelo código transparente. O código transparente jamais pode chamar diretamente o código nativo por meio de um P/Invoke. Por isso, a marcação de um P/Invoke como crítico de segurança não permitirá que o código transparente o chame, e é enganosa na análise de segurança.|
|[CA5361: não desabilitar o uso do SChannel de criptografia forte](../code-quality/ca5361.md)|A definição de `Switch.System.Net.DontEnableSchUseStrongCrypto` para `true` enfraquece a criptografia usada em conexões de TLS (segurança da camada de transporte) de saída. A criptografia mais fraca pode comprometer a confidencialidade da comunicação entre o aplicativo e o servidor, tornando mais fácil para os invasores bisbilhotarem dados confidenciais.|
|[CA5363: não desabilitar a validação de solicitação](../code-quality/ca5363.md)|A validação de solicitação é um recurso no ASP.NET que examina as solicitações HTTP e determina se elas contêm conteúdo potencialmente perigoso que pode levar a ataques de injeção, incluindo scripts entre sites.|
|[CA5364: não use protocolos de segurança preteridos](../code-quality/ca5364.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5369: Use XmlReader para desserializar](../code-quality/ca5369.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas, que devem ser restringidas com o uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5370: usar XmlReader para validar o leitor](../code-quality/ca5370.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. Esse carregamento perigoso pode ser restringido usando um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5371: usar XmlReader para leitura de esquema](../code-quality/ca5371.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. O uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado restringe isso.|
|[CA5372: usar XmlReader para XPathDocument](../code-quality/ca5372.md)|O processamento de XML de dados não confiáveis pode carregar referências externas perigosas, que podem ser restringidas usando um XmlReader com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5373: não usar função de derivação de chave obsoleta](../code-quality/ca5373.md)|Essa regra detecta a invocação de métodos de derivação de chave fraca <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> e `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> usou um algoritmo fraco PBKDF1.|
|[CA5378: não desabilitar ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Definir `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` como `true` limita as conexões de TLS (segurança de camada de transporte) do Windows Communication Framework (WCF) usando o TLS 1,0. Essa versão do TLS será preterida.|
|[CA5380: não adicionar certificados ao repositório raiz](../code-quality/ca5380.md)|Essa regra detecta o código que adiciona um certificado ao repositório de certificados das autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs públicas que atendem aos requisitos do programa de certificado raiz da Microsoft.|
|[CA5381: Certifique-se de que os certificados não sejam adicionados ao repositório raiz](../code-quality/ca5381.md)|Essa regra detecta o código que potencialmente adiciona um certificado ao repositório de certificados de autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs (autoridades de certificação) públicas que atendem aos requisitos do Microsoft Root Certificate Program.|
|[CA5386: Evite codificar o valor de SecurityProtocolType](../code-quality/ca5386.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo e ter como destino pelo menos .NET Framework v 4.7.1.|
|[CA5389: não adicionar o caminho do item de arquivamento ao caminho do sistema de arquivos de destino](../code-quality/ca5389.md)|O caminho do arquivo pode ser relativo e pode levar ao acesso do sistema de arquivos fora do caminho de destino do sistema de arquivos esperado, levando a alterações de configuração mal-intencionadas e à execução remota de código por meio da técnica de Lay-and-wait.|
|[CA5397: não usar valores de SslProtocols preteridos](../code-quality/ca5397.md)|o TLS (ransport Layer Security) protege a comunicação entre computadores, mais comumente com o protocolo HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5398: evitar valores de SslProtocols codificados](../code-quality/ca5398.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo.|
