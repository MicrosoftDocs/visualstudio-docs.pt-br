---
title: 'CA1303: não passar literais como parâmetros localizados'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: e6b4fad16bc1c4b205ea09a39af8d38e08db848f
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/21/2020
ms.locfileid: "81649180"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: não passar literais como parâmetros localizados

|||
|-|-|
|TypeName|DoNotPassLiteralsAsLocalizedParameters|
|CheckId|CA1303|
|Categoria|Microsoft.Globalização|
|Mudança de ruptura|Não quebrando|

## <a name="cause"></a>Causa

Um método passa uma seqüência literal como um parâmetro para um construtor ou método .NET e essa string deve ser localizada.

Este aviso é levantado quando uma seqüência literal é passada como um valor para um parâmetro ou propriedade e um ou mais dos seguintes casos são verdadeiros:

- O <xref:System.ComponentModel.LocalizableAttribute> atributo do parâmetro ou propriedade é definido como verdadeiro.

- O nome do parâmetro de seqüência que é passado para um método Console.Write ou Console.WriteLine é "valor" ou "formato".

Por padrão, esta regra analisa toda a base de código, mas isso é [configurável](#excluded-type-names-with-derived-types).

Começando pela versão 3.0.0 do pacote analisador, a heurística de nomeação não é mais usada por padrão, mas isso é [configurável](#use-naming-heuristic).

## <a name="rule-description"></a>Descrição da regra

Literais de cordas que estão incorporados no código fonte são difíceis de localizar.

## <a name="how-to-fix-violations"></a>Como corrigir violações

Para corrigir uma violação desta regra, substitua a seqüência <xref:System.Resources.ResourceManager> literal por uma string recuperada através de uma instância da classe.

## <a name="when-to-suppress-warnings"></a>Quando suprimir avisos

É seguro suprimir um aviso desta regra se a biblioteca de código não for localizada ou se a string não estiver exposta ao usuário final ou a um desenvolvedor que use a biblioteca de códigos.

Os usuários podem eliminar o ruído contra métodos que não devem ser passados em strings localizadas, renomeando o parâmetro ou a propriedade, ou marcando esses itens como condicionais.

## <a name="configurability"></a>Configurabilidade

Se você estiver executando esta regra de [analisadores FxCop](install-fxcop-analyzers.md) (e não com análise de legado), essa regra é configurável.

### <a name="excluded-type-names-with-derived-types"></a>Nomes de tipos excluídos com tipos derivados

Você pode configurar quais tipos, incluindo seus tipos derivados, para excluir da análise. Por exemplo, para especificar que a regra não `MyType` deve ser executada em nenhum método dentro de tipos nomeados e seus tipos derivados, adicione o seguinte par de valor de chave a um arquivo .editorconfig em seu projeto:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formatos de nome de símbolo permitidos no valor da opção (separados por '|'):

- Somente nome de tipo (inclui todos os tipos com o nome, independentemente do tipo ou namespace que contêm)
- Nomes totalmente qualificados no formato de [ID](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format) `T:` de documentação do símbolo, com um prefixo opcional.

Exemplos:

| Valor de Opção | Resumo |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Corresponde a todos os tipos chamados 'MyType' e todos os seus tipos derivados na compilação
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Corresponde a todos os tipos chamados 'MyType1' ou 'MyType2' e todos os seus tipos derivados na compilação
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Corresponde ao tipo específico 'MyType' com nome dado totalmente qualificado e todos os seus tipos derivados
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Corresponde aos tipos específicos 'MyType1' e 'MyType2' com seus respectivos nomes totalmente qualificados e todos os seus tipos derivados

Você pode configurar esta opção apenas para esta regra, para todas as regras, ou para todas as regras nesta categoria (Globalização). Para obter mais informações, consulte [Configure analisadores FxCop](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Use nomeação heurística

Você pode configurar se parâmetros ou propriedades que contenham "Texto", "Mensagem" ou "Legenda" ativarão essa regra.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Exemplo

O exemplo a seguir mostra um método que lança uma exceção quando qualquer um de seus dois argumentos está fora de alcance. Para o primeiro argumento, o construtor de exceção é aprovado uma seqüência literal, o que viola essa regra. Para o segundo argumento, o construtor é corretamente <xref:System.Resources.ResourceManager>passado uma seqüência recuperada através de um .

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Confira também

- [Recursos em aplicativos de área de trabalho](/dotnet/framework/resources/index)
- [Pedido da comunidade para mudança de comportamento](https://github.com/dotnet/roslyn-analyzers/issues/2933)
