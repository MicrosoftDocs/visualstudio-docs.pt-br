---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011681"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Mover, copiar, reatribuir ou redefinir um ponteiro inteligente local".

**C++ Principais diretrizes**: R. 5: Prefira objetos com escopo, não aloque heap desnecessariamente

Os ponteiros inteligentes são convenientes para o gerenciamento dinâmico de recursos, mas nem sempre são necessários. Por exemplo, a criação de um buffer dinâmico local pode ser facilmente (end às vezes com mais eficiência) gerenciado por contêineres padrão. Para objetos únicos, pode ser desnecessário fazer uma alocação dinâmica (por exemplo, se esses objetos nunca sobreviver Alémm sua função de criador) e eles podem ser substituídos por variáveis locais. Os ponteiros inteligentes se tornam úteis quando o cenário requer alteração de propriedade, ou seja, a reatribuição de um recurso dinâmico várias vezes ou em vários caminhos. Isso também inclui casos em que os recursos são obtidos do código externo e os ponteiros inteligentes são usados para estender o tempo de vida do recurso.

## <a name="remarks"></a>Comentários

- Além dos modelos padrão std:: unique_pointer e std:: shared_pointer, essa verificação reconhece os tipos definidos pelo usuário que provavelmente pretendem ser apontadores inteligentes. Esses tipos são esperados para definir as seguintes operações:
  - desreferência ou operadores de acesso de membro sobrecarregados, que são públicos e não marcados como excluídos;
  - destruidor público que não é excluído nem padronizado. Isso inclui destruidores que são definidos explicitamente como vazios.
  - O tipo Microsoft:: WRL:: ComPtr se comporta como um ponteiro compartilhado, mas geralmente é usado em cenários bastante específicos que são afetados pelo gerenciamento de tempo de vida de COM. Para evitar o ruído excessivo, esse tipo é filtrado.
  - Essa verificação procura por alocações locais explícitas atribuídas a ponteiros inteligentes para identificar se as variáveis com escopo poderiam ser palavras como uma alternativa. Além das chamadas diretas para o operador novo, funções especiais como std:: make_unique e std:: make_shared também são interpretadas como Alocações diretas.

## <a name="example"></a>Exemplo

buffer dinâmico

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

buffer dinâmico – substituído pelo contêiner

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
