---
title: 'CA2000: descartar objetos antes de perder o escopo'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615580"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: descartar objetos antes de perder o escopo

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Categoria|Microsoft.Confiabilidade|
|Mudança de ruptura|Não quebrando|

## <a name="cause"></a>Causa

Um objeto local <xref:System.IDisposable> de um tipo é criado, mas o objeto não é descartado antes que todas as referências ao objeto estejam fora do escopo.

Por padrão, esta regra analisa toda a base de código, mas isso é [configurável](#configurability).

## <a name="rule-description"></a>Descrição da regra

Se um objeto descartável não for descartado explicitamente antes que todas as referências a ele estejam fora de escopo, o objeto será descartado em algum momento indeterminado quando o coletor de lixo executa o finalizador do objeto. Como pode ocorrer um evento excepcional que impeça o finalizador do objeto de ser executado, o objeto deve ser explicitamente descartado.

### <a name="special-cases"></a>Casos especiais

A regra CA2000 não é acionada para objetos locais dos seguintes tipos, mesmo que o objeto não esteja descartado:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Passar um objeto de um desses tipos para um construtor e, em seguida, atribuí-lo a um campo indica uma *transferência de propriedade de descarte* para o tipo recém-construído. Ou seja, o tipo recém-construído é agora responsável pelo descarte do objeto. Se o seu código passar um objeto de um desses tipos para um construtor, nenhuma violação da regra CA2000 ocorrerá mesmo que o objeto não seja descartado antes que todas as referências a ele estejam fora do escopo.

## <a name="how-to-fix-violations"></a>Como corrigir violações

Para corrigir uma violação desta <xref:System.IDisposable.Dispose%2A> regra, ligue para o objeto antes que todas as referências a ele estejam fora do escopo.

Você pode usar[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) a [ `using` declaração](/dotnet/csharp/language-reference/keywords/using-statement) (no Visual <xref:System.IDisposable>Basic) para embrulhar objetos que implementam . Os objetos que são embrulhados desta forma são `using` automaticamente descartados no final do bloco. No entanto, as seguintes situações `using` não devem ou não podem ser tratadas com uma declaração:

- Para devolver um objeto descartável, o `try/finally` objeto deve `using` ser construído em um bloco fora de um bloco.

- Não inicialize membros de um objeto descartável `using` na construtora de uma declaração.

- Quando os construtores protegidos por apenas um manipulador de exceção estão aninhados na [parte de aquisição de uma `using` declaração,](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)uma falha na construtora externa pode resultar no objeto criado pelo construtor aninhado nunca ser fechado. No exemplo a seguir, <xref:System.IO.StreamReader> uma falha no <xref:System.IO.FileStream> construtor pode resultar em que o objeto nunca seja fechado. Ca2000 sinaliza uma violação da regra neste caso.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Objetos dinâmicos devem usar um objeto <xref:System.IDisposable> de sombra para implementar o padrão de descarte de objetos.

## <a name="when-to-suppress-warnings"></a>Quando suprimir avisos

Não suprima uma advertência desta regra a menos que:

- Você chamou um método em seu `Dispose`objeto que chama, como<xref:System.IO.Stream.Close%2A>
- O método que levantou o <xref:System.IDisposable> aviso retorna um objeto que envolve seu objeto
- O método de alocação não possui propriedade de descarte; ou seja, a responsabilidade de descartar o objeto é transferida para outro objeto ou invólucro que é criado no método e devolvido ao chamador

## <a name="configurability"></a>Configurabilidade

Se você estiver executando esta regra de [analisadores FxCop](install-fxcop-analyzers.md) (e não com análise de legado), você pode configurar a análise para esta regra.

### <a name="excluded-symbol-names"></a>Nomes de símbolos excluídos

Você pode configurar quais partes da sua base de código para excluir da análise. Por exemplo, para especificar que a regra não `MyType`deve ser executada em qualquer código dentro de tipos nomeados, adicione o seguinte par de valorde chave a um arquivo .editorconfig em seu projeto:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Formatos de nome de símbolo permitidos no valor da opção (separados por '|'):
  - Somente nome do símbolo (inclui todos os símbolos com o nome, independentemente do tipo ou namespace que contêm)
  - Nomes totalmente qualificados no formato de ID de [documentação](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)do símbolo . Cada nome de símbolo requer um prefixo tipo símbolo, como "M:" prefixo para métodos, prefixo "T:" para tipos, prefixo "N:" para namespaces, etc.
  - `.ctor`para construtores `.cctor` e para construtores estáticos

Exemplos:

| Valor de Opção | Resumo |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Corresponde a todos os símbolos chamados 'MyType' na compilação
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Corresponde a todos os símbolos chamados 'MyType1' ou 'MyType2' na compilação
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Corresponde ao método específico 'MyMethod' com a assinatura totalmente qualificada
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Corresponde aos métodos específicos 'MyMethod1' e 'MyMethod2' com respectiva assinatura totalmente qualificada

Você pode configurar todas essas opções apenas para esta regra, para todas as regras ou para todas as regras nesta categoria (Design). Para obter mais informações, consulte [Configure analisadores FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Regras relacionadas

- [CA2213: os campos descartáveis devem ser descartados](../code-quality/ca2213.md)
- [CA2202: não descartar objetos várias vezes](../code-quality/ca2202.md)

## <a name="example"></a>Exemplo

Se você estiver implementando um método que devolva um objeto descartável, use um try/finally block sem um bloco de captura para garantir que o objeto esteja descartado. Ao usar um bloco try/finally, você permite que exceções sejam levantadas no ponto de falha e certifique-se de que o objeto está descartado.

No método OpenPort1, a chamada para abrir o objeto ISerializable SerialPort ou a chamada para SomeMethod pode falhar. Um aviso CA2000 é levantado sobre esta implementação.

No método OpenPort2, dois objetos SerialPort são declarados e definidos como nulos:

- `tempPort`, que é usado para testar que as operações do método têm sucesso.

- `port`, que é usado para o valor de retorno do método.

O `tempPort` é construído e `try` aberto em um bloco, e qualquer `try` outro trabalho necessário é realizado no mesmo bloco. No final do `try` bloco, a porta aberta `port` é atribuída ao objeto `tempPort` que será `null`devolvido e o objeto é definido como .

O `finally` bloco verifica `tempPort`o valor de . Se não for nulo, uma operação no `tempPort` método falhou e está fechada para garantir que os recursos sejam liberados. O objeto de porta retornado conterá o objeto SerialPort aberto se as operações do método forem bem sucedidas ou se uma operação falhar.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Exemplo

Por padrão, o compilador Visual Basic tem todos os operadores aritméticos verificar se há transbordamento. Portanto, qualquer operação aritmética visual <xref:System.OverflowException>básica pode lançar um . Isso pode levar a violações inesperadas em regras como o CA2000. Por exemplo, a seguinte função CreateReader1 produzirá uma violação CA2000 porque o compilador Visual Basic está emitindo uma instrução de verificação de transbordamento para a adição que poderia lançar uma exceção que faria com que o StreamReader não fosse eliminado.

Para corrigir isso, você pode desativar a emissão de verificações de estouro pelo compilador Visual Basic em seu projeto ou você pode modificar seu código como na seguinte função CreateReader2.

Para desativar a emissão de verificações de estouro, clique com o botão direito do mouse no nome do projeto no Solution Explorer e clique em **Propriedades**. Clique **em Compilar,** clique **em Opções avançadas de compilação**e, em seguida, verifique **Remover verificações de estouro**inteiro .

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Confira também

- <xref:System.IDisposable>
- [Padrão de descarte](/dotnet/standard/design-guidelines/dispose-pattern)
