---
title: Avisos de segurança
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9e7a21a010cf98da3d7adb9627105c2847b7571e
ms.sourcegitcommit: a77158415da04e9bb8b33c332f6cca8f14c08f8c
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/15/2020
ms.locfileid: "86386349"
---
# <a name="security-warnings"></a>Avisos de segurança

Os avisos de segurança oferecem suporte a bibliotecas e aplicativos mais seguros. Esses avisos ajudam a evitar falhas de segurança em seu programa. Se você desabilitar um desses avisos, você deve marcar claramente a razão no código e também informar o agente de segurança designado para seu projeto de desenvolvimento.

## <a name="in-this-section"></a>Nesta seção

|Regra|Descrição|
|----------|-----------------|
|[CA2100: Examinar consultas SQL em busca de vulnerabilidades de segurança](../code-quality/ca2100.md)|Um método define a propriedade System.Data.IDbCommand.CommandText usando uma cadeia de caracteres criada com base em um argumento da cadeia de caracteres para o método. Esta regra pressupõe que o argumento da cadeia de caracteres contenha a entrada do usuário. Uma cadeia de caracteres de comando SQL criada com base na entrada do usuário é vulnerável a ataques de injeção SQL.|
|[CA2102: Capturar exceções não CLSCompliant em manipuladores gerais](../code-quality/ca2102.md)|Um membro em um assembly que não é marcado com o RuntimeCompatibilityAttribute ou que é marcado como RuntimeCompatibility (WrapNonExceptionThrows = false) contém um bloco de captura que trata System.Exception e não contém um bloco de captura geral imediatamente posterior.|
|[CA2103: Examinar a segurança imperativa](../code-quality/ca2103.md)|Um método usa segurança obrigatória e pode construir a permissão usando as informações de estado ou os valores de retorno que podem ser alterados enquanto a demanda estiver ativa. Use a segurança declarativa sempre que possível.|
|[CA2104: Não declarar tipos de referência mutáveis somente leitura](../code-quality/ca2104.md)|Um tipo visível externamente contém um campo somente leitura visível externamente que é um tipo de referência mutável. Um tipo mutável é um tipo cujos dados da instância podem ser modificados.|
|[CA2105: Campos de matrizes não devem ser somente leitura](../code-quality/ca2105.md)|Quando você aplica o modificador somente leitura (ReadOnly no Visual Basic) a um campo que contém uma matriz, o campo não pode ser alterado para fazer referência a uma matriz diferente. No entanto, os elementos da matriz armazenados em um campo somente leitura podem ser alterados.|
|[CA2106: Declarações seguras](../code-quality/ca2106.md)|Um método declara uma permissão e nenhuma verificação de segurança é realizada no chamador. A declaração de uma permissão de segurança sem realizar verificações de segurança pode deixar uma fraqueza de segurança explorável no código.|
|[CA2107: Examinar uso de deny e permit only](../code-quality/ca2107.md)|Usar o método PermitOnly e as ações de segurança CodeAccessPermission. Deny devem ser usados somente por aqueles com conhecimento avançado de segurança do .NET. O código que usa essas ações de segurança deve passar por uma revisão de segurança.|
|[CA2108: Examinar a segurança declarativa em tipos de valor](../code-quality/ca2108.md)|Um tipo de valor público ou protegido é resguardado por acesso a dados ou exigências de vínculo.|
|[CA2109: Examinar manipuladores de eventos visíveis](../code-quality/ca2109.md)|Um método público ou protegido de tratamento de eventos foi detectado. Os métodos de tratamento de eventos não devem ser expostos, a menos que seja absolutamente necessário.|
|[CA2111: Ponteiros não devem ser visíveis](../code-quality/ca2111.md)|Um ponteiro não é privado, interno ou somente leitura. Um código mal-intencionado pode alterar o valor do ponteiro, permitindo o acesso a locais arbitrários na memória ou causando falhas no aplicativo ou no sistema.|
|[CA2112: Tipos protegidos não devem expor campos](../code-quality/ca2112.md)|Um tipo público ou protegido contém campos públicos e é protegido por exigências de vínculo. Se tiver acesso a uma instância de um tipo protegido por uma exigência de vínculo, o código não precisará atender à exigência de vínculo para acessar os campos do tipo.|
|[CA2114: A segurança do método deve ser um superconjunto do tipo](../code-quality/ca2114.md)|Um método não deve ter segurança declarativa no nível do método e no nível do tipo para a mesma ação.|
|[CA2115: Chamar GC.KeepAlive ao usar recursos nativos](../code-quality/ca2115.md)|Esta regra detecta erros que podem ocorrer porque um recurso não gerenciado está sendo finalizado, enquanto ainda está sendo usado em código não gerenciado.|
|[CA2116: Métodos APTCA devem chamar somente métodos APTCA](../code-quality/ca2116.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e o assembly executar código em outro assembly que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2117: Tipos APTCA devem estender somente tipos base APTCA](../code-quality/ca2117.md)|Quando o atributo APTCA (AllowPartiallyTrustedCallers) estiver presente em um assembly totalmente confiável e um tipo no assembly for herdado de um tipo que não permita chamadores parcialmente confiáveis, será possível uma exploração de segurança.|
|[CA2118: Examinar o uso de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute altera o comportamento do sistema de segurança padrão para membros que executem código não gerenciado que usa interoperabilidade COM ou invocação da plataforma. Esse atributo é usado principalmente para aumentar o desempenho; no entanto, os ganhos de desempenho acompanham riscos de segurança significativos.|
|[CA2119: Selar métodos que atendem a interfaces particulares](../code-quality/ca2119.md)|Um tipo público herdável fornece uma implementação de método substituível de uma interface (Friend no Visual Basic) interna. Para corrigir uma violação dessa regra, evite que o método seja substituído fora do assembly.|
|[CA2120: Construtores de serialização seguros](../code-quality/ca2120.md)|Esse tipo tem um construtor que utiliza um objeto System.Runtime.Serialization.SerializationInfo e um objeto System.Runtime.Serialization.StreamingContext (a assinatura do construtor de serialização). Esse construtor não é protegido por uma verificação de segurança, mas um ou mais dos construtores regulares no tipo são protegidos.|
|[CA2121: Construtores estáticos devem ser particulares](../code-quality/ca2121.md)|O sistema chama o construtor estático antes que a primeira instância do tipo seja criada ou que outros membros estáticos sejam referenciados. Se não for privado, um construtor estático poderá ser chamado por um código diferente do sistema. Dependendo das operações realizadas no construtor, isso pode causar um comportamento inesperado.|
|[CA2122: Não expor indiretamente métodos com demandas de link](../code-quality/ca2122.md)|Um membro público ou protegido tem exigências de vínculo e é chamado por um membro que não realiza nenhuma verificação de segurança. Uma exigência de vínculo verifica as permissões apenas do chamador imediato.|
|[CA2123: As demandas de link de substituição devem ser idênticas à base](../code-quality/ca2123.md)|Esta regra compara um método ao método de base, que é uma interface ou um método virtual em outro tipo e, em seguida, compara as exigências de vínculo em cada um. Se essa regra for violada, um chamador mal-intencionado poderá ignorar a exigência de vínculo apenas chamando o método não seguro.|
|[CA2124: Encapsular cláusulas finally vulneráveis em try externo](../code-quality/ca2124.md)|Um método público ou protegido contém um bloco try/finally. O bloco finally aparentemente redefine o estado de segurança não está incluído em um bloco finally.|
|[CA2126: As demandas de link de tipo exigem demandas de herança](../code-quality/ca2126.md)|Um tipo sem lacre público é protegido com uma exigência de link e tem um método substituível. Nem o tipo nem o método é protegido com uma exigência de herança.|
|[CA2130: Constantes críticas de segurança devem ser transparentes](../code-quality/ca2130.md)|A imposição de transparência não é imposta para valores constantes porque compiladores têm valores constantes internos de modo que nenhuma pesquisa seja necessária no tempo de execução. Os campos constantes devem ter segurança transparente de forma que os revisores de código não pressuponham que o código transparente não pode acessar a constante.|
|[CA2131: Tipos críticos de segurança podem não participar da equivalência de tipo](../code-quality/ca2131.md)|Um tipo participa da equivalência de tipo e o próprio tipo, ou um membro ou campo do tipo, é marcado com o atributo SecurityCriticalAttribute. Esta regra é acionada em qualquer tipo crítico ou em tipos que contenham métodos críticos ou campos que estejam participando da equivalência do tipo. Ao detectar um tipo assim, o CLR não o carrega com um TypeLoadException em tempo de execução. Normalmente, essa regra só é acionada quando usuários implementam equivalência de tipo manualmente, em vez de depender de tlbimp e dos compiladores para fazer a equivalência do tipo.|
|[CA2132: Construtores padrão devem ser pelo menos tão críticos quanto construtores padrão do tipo base](../code-quality/ca2132.md)|Os tipos e os membros que têm o SecurityCriticalAttribute não podem ser usados pelo código de aplicativo do Silverlight. Os tipos de segurança crítica e os membros só podem ser usados por código confiável no .NET Framework para a biblioteca de classes do Silverlight. Como uma construção pública ou protegida em uma classe derivada deve ter a mesma transparência maior que sua classe base, uma classe em um aplicativo não pode ser derivada de uma classe marcada como SecurityCritical.|
|[CA2133: Representantes devem ser associados a métodos com transparência consistente](../code-quality/ca2133.md)|Esse aviso é acionado em um método que associa um representante que foi marcado com o SecurityCriticalAttribute para um método transparente ou marcado com o SecuritySafeCriticalAttribute. O aviso também é acionado em um método que associa um representante transparente ou de segurança crítica a um método crítico.|
|[CA2134: Os métodos devem manter uma transparência consistente durante a substituição dos métodos base](../code-quality/ca2134.md)|Essa regra é acionada quando um método marcado com o SecurityCriticalAttribute substitui um método transparente ou marcado com o SecuritySafeCriticalAttribute. A regra também é acionada quando um método transparente ou marcado com o SecuritySafeCriticalAttribute substitui um método marcado com um SecurityCriticalAttribute. A regra é aplicada durante a substituição de um método virtual ou a implementação de uma interface.|
|[CA2135: Os assemblies de nível 2 não devem conter LinkDemands](../code-quality/ca2135.md)|LinkDemands são preteridos no conjunto de regras de segurança nível 2. Em vez de usar LinkDemands para impor a segurança em tempo de compilação JIT (just-in-time), marque os métodos, os tipos e os campos com o atributo SecurityCriticalAttribute.|
|[CA2136: Membros não devem ter anotações de transparência conflitantes](../code-quality/ca2136.md)|Os atributos de transparência são aplicados com base nos elementos de código de escopo maior a elementos de escopo menor. Os atributos de transparência dos elementos de código com escopo maior têm precedência sobre atributos de transparência dos elementos de código contidos no primeiro elemento. Por exemplo, uma classe marcada com o atributo SecurityCriticalAttribute não pode conter um método marcado com o atributo SecuritySafeCriticalAttribute.|
|[CA2137: Métodos transparentes devem conter apenas a IL verificável](../code-quality/ca2137.md)|Um método contém código não verificável ou retorna um tipo por referência. Esta regra é acionada em tentativas por código transparente de segurança para executar MSIL (Microsoft Intermediate Language) não verificável. Entretanto, a regra não contém um verificador de IL completo e, em vez disso, usa heurística para capturar a maioria das violações de verificação de MSIL.|
|[CA2138: Métodos transparentes não devem chamar métodos com o atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Um método de segurança transparente chama um método marcado com o atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Métodos transparentes podem não usar o atributo HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Essa regra é acionada em qualquer método transparente e tenta manipular um processo que corrompe a exceção usando o atributo HandleProcessCorruptedStateExceptionsAttribute. Uma exceção de corrompimento de processo é uma classificação de exceção do CLR versão 4,0 de exceções como <xref:System.AccessViolationException> . O atributo HandleProcessCorruptedStateExceptionsAttribute só pode ser usado por métodos de segurança crítica e será ignorado se for aplicado a um método transparente.|
|[CA2140: O código transparente não deve referenciar itens críticos de segurança](../code-quality/ca2140.md)|Métodos que são marcados com SecurityTransparentAttribute chamam membros não públicos marcados como SecurityCritical. Essa regra analisa todos os métodos e tipos em um assembly misto transparente e crítico e sinaliza todas as chamadas do código Transparent para um código crítico não público que não esteja marcado como SecurityTreatAsSafe.|
|[CA2141:Transparent métodos não devem atender a LinkDemands](../code-quality/ca2141.md)|Um método transparente de segurança chama um método em um assembly que não foi marcado com o atributo APTCA (AllowPartiallyTrustedCallersAttribute) ou um método transparente de segurança atende a um LinkDemand para um tipo ou um método.|
|[CA2142: O código transparente não deve ser protegido com LinkDemands](../code-quality/ca2142.md)|Esta regra é acionada em métodos transparentes que exigem LinkDemands para serem acessados. O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões.|
|[CA2143: Métodos transparentes não devem usar demandas de segurança](../code-quality/ca2143.md)|O código transparente de segurança não deve ser responsável por verificar a segurança de uma operação e, assim, não deve exigir permissões. O código transparente de segurança deve usar demandas completas para tomar decisões de segurança e o código crítico de segurança não deve confiar no código transparente para fazer a demanda completa.|
|[CA2144: O código transparente não deve carregar assemblies de matrizes de bytes](../code-quality/ca2144.md)|A revisão de segurança para o código transparente não é tão completo quanto a revisão de segurança para o código crítico porque o código transparente não pode realizar ações confidenciais de segurança. Os assemblies carregados a partir de uma matriz de bytes podem não ser observados no código transparente e essa matriz de bytes pode conter código crítico ou código crítico de segurança mais importante, que precisa ser auditado.|
|[CA2145: Métodos transparentes não devem ser decorados com o SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Os métodos decorados com o atributo SuppressUnmanagedCodeSecurityAttribute têm um LinkDemand implícito colocado em qualquer método que o chame. Este LinkDemand requer que o código de chamada seja crítico de segurança. A marcação do método que usa SuppressUnmanagedCodeSecurity com o atributo SecurityCriticalAttribute torna esse requisito mais óbvio para chamadores do método.|
|[CA2146: Os tipos devem ser pelo menos tão críticos quanto seus tipos base e interfaces](../code-quality/ca2146.md)|Esta regra é acionada quando um tipo derivado tem um atributo de transparência de segurança que não é tão crítico quanto seu tipo de base ou interface implementada. Apenas os tipos críticos podem derivar os tipos de base críticos ou implementar interfaces críticos, e apenas os tipos críticos ou de segurança crítica podem derivar dos tipos de base críticos de segurança ou implementar interfaces críticas de segurança.|
|[CA2147: Métodos transparentes podem não usar declarações de segurança](../code-quality/ca2147.md)|Esta regra analisa todos os métodos e tipos em um assembly que seja 100% transparente ou transparente/crítico misto e sinaliza o uso declarativo ou obrigatório de Assert.|
|[CA2149: Métodos transparentes não devem chamar código nativo](../code-quality/ca2149.md)|Essa regra é acionada em qualquer método transparente que chama diretamente em código nativo, por exemplo, por meio de um P/Invoke. As violações dessa regra resultam em um MethodAccessException no modelo de transparência de nível 2 e uma demanda completa para UnmanagedCode no modelo de transparência de nível 1.|
|[CA2151: Campos com tipos críticos devem ser críticos para segurança](../code-quality/ca2151.md)|Para usar tipos de segurança crítica, o código que faz referência ao tipo deve ser de segurança crítica ou de segurança crítica segura. Isso será verdadeiro mesmo que a referência seja indireta. Por isso, ter um campo de segurança transparente ou de segurança crítica é enganoso porque o código transparente continuará incapaz de acessar o campo.|
|[CA2153: Evitar tratamento de exceções de estado corrompido](../code-quality/ca2153.md)|As [exceções de estado corrompidas (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicam que há corrupção de memória em seu processo. A captura deles, em vez de permitir que o processo falhe, pode levar a vulnerabilidades de segurança se um invasor puder fazer uma exploração na região de memória corrompida.|
|[CA2300: Não usar o desserializador BinaryFormatter não seguro](../code-quality/ca2300.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2301: Não chamar BinaryFormatter.Deserialize sem antes definir BinaryFormatter.Binder](../code-quality/ca2301.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2302: Verificar se o BinaryFormatter.Binder está definido antes de chamar BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2305: Não usar o desserializador inseguro LosFormatter](../code-quality/ca2305.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2310: Não usar o desserializador inseguro NetDataContractSerializer](../code-quality/ca2310.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2311: Não desserializar sem definir primeiro NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2312: Verificar se NetDataContractSerializer.Binder foi definido antes de desserializar](../code-quality/ca2312.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2315: Não usar o desserializador inseguro ObjectStateFormatter](../code-quality/ca2315.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2321: Não desserializar com JavaScriptSerializer usando um SimpleTypeResolver](../code-quality/ca2321.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2322: Garantir que o JavaScriptSerializer não seja inicializado com SimpleTypeResolver antes de desserializar](../code-quality/ca2322.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2326: Não usar valores de TypeNameHandling diferentes de None](../code-quality/ca2326.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2327: Não usar JsonSerializerSettings não seguras](../code-quality/ca2327.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2328: Verificar se as JsonSerializerSettings são seguras](../code-quality/ca2328.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2329: Não desserializar com JsonSerializer usando uma configuração não segura](../code-quality/ca2329.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2330: Verificar se o JsonSerializer tem uma configuração segura durante a desserialização](../code-quality/ca2330.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2350: Verifique se a entrada de DataTable. ReadXml () é confiável](ca2350.md)|Ao desserializar um <xref:System.Data.DataTable> com uma entrada não confiável, um invasor pode criar uma entrada mal-intencionada para executar um ataque de negação de serviço. Pode haver vulnerabilidades de execução remota de código desconhecido.|
|[CA2351: Verifique se a entrada do conjunto de dados. ReadXml () é confiável](ca2351.md)|Ao desserializar um <xref:System.Data.DataSet> com uma entrada não confiável, um invasor pode criar uma entrada mal-intencionada para executar um ataque de negação de serviço. Pode haver vulnerabilidades de execução remota de código desconhecido.|
|[CA2352: DataSet ou DataTable não seguro em tipo serializável pode ser vulnerável a ataques de execução remota de código](ca2352.md)|Uma classe ou estrutura marcada com <xref:System.SerializableAttribute> contém um <xref:System.Data.DataSet> <xref:System.Data.DataTable> campo ou propriedade, e não tem um <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: DataSet ou DataTable não seguro em tipo serializável](ca2353.md)|Uma classe ou struct marcada com um atributo de serialização XML ou um atributo de contrato de dados contém um <xref:System.Data.DataSet> <xref:System.Data.DataTable> campo ou propriedade.|
|[CA2354: DataSet ou DataTable não seguro em um grafo de objeto desserializado pode ser vulnerável a ataques de execução remota de código](ca2354.md)|A desserialização com uma <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializada e o grafo de objeto do tipo convertido podem incluir um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2355: DataSet ou DataTable não seguro no grafo de objeto desserializado](ca2355.md)|Desserializando quando o grafo de objeto do tipo convertido ou especificado pode incluir um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2356: DataSet não seguro ou DataTable no grafo de objeto desserializado da Web](ca2356.md)|Um método com um <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> ou <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> tem um parâmetro que pode fazer referência a um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA3001: Examinar código quanto a vulnerabilidades de injeção de SQL](../code-quality/ca3001.md)|Ao trabalhar com comandos de entrada e SQL não confiáveis, lembre-se dos ataques de injeção de SQL. Um ataque de injeção de SQL pode executar comandos SQL mal-intencionados, comprometendo a segurança e a integridade do seu aplicativo.|
|[CA3002: Examinar código quanto a vulnerabilidades de XSS](../code-quality/ca3002.md)|Ao trabalhar com entrada não confiável de solicitações da Web, tenha cuidado com ataques XSS (scripts entre sites). Um ataque XSS injeta entrada não confiável em saída HTML bruta, permitindo que o invasor execute scripts mal-intencionados ou modifique conteúdo de forma mal-intencionada em sua página da Web.|
|[CA3003: Examinar código quanto a vulnerabilidades de injeção de caminho](../code-quality/ca3003.md)|Ao trabalhar com entrada não confiável de solicitações da Web, lembre-se de usar a entrada controlada pelo usuário ao especificar caminhos para arquivos.|
|[CA3004: Examinar código quanto a vulnerabilidades de divulgação de informações](../code-quality/ca3004.md)|A divulgação de informações de exceção dá aos invasores insights sobre os internos do seu aplicativo, o que pode ajudar os invasores a encontrar outras vulnerabilidades a serem exploradas.|
|[CA3006: Examinar código quanto a vulnerabilidades de injeção de comando de processo](../code-quality/ca3006.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de comando. Um ataque de injeção de comando pode executar comandos mal-intencionados no sistema operacional subjacente, comprometendo a segurança e a integridade do servidor.|
|[CA3007: Examinar código quanto a vulnerabilidades de redirecionamento aberto](../code-quality/ca3007.md)|Ao trabalhar com entrada não confiável, lembre-se de vulnerabilidades de redirecionamento abertas. Um invasor pode explorar uma vulnerabilidade de redirecionamento aberto para usar seu site para dar a aparência de uma URL legítima, mas redirecionar um visitante dessuspeito para um phishing ou outra página da Web mal-intencionada.|
|[CA3008: Examinar código quanto a vulnerabilidades de injeção de XPath](../code-quality/ca3008.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XPath. A construção de consultas XPath usando a entrada não confiável pode permitir que um invasor manipule a consulta de forma mal-intencionada para retornar um resultado indesejado e possivelmente divulgar o conteúdo do XML consultado.|
|[CA3009: Examinar código quanto a vulnerabilidades de injeção de XML](../code-quality/ca3009.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XML.|
|[CA3010: Examinar código quanto a vulnerabilidades de injeção de XAML](../code-quality/ca3010.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção XAML. XAML é uma linguagem de marcação que representa diretamente a instanciação e execução de objetos. Isso significa que os elementos criados em XAML podem interagir com recursos do sistema (por exemplo, acesso à rede e e/s do sistema de arquivos).|
|[CA3011: Examinar código quanto a vulnerabilidades de injeção de DLL](../code-quality/ca3011.md)|Ao trabalhar com uma entrada não confiável, lembre-se de carregar código não confiável. Se o seu aplicativo Web carregar código não confiável, um invasor poderá injetar DLLs mal-intencionadas em seu processo e executar código mal-intencionado.|
|[CA3012: Examinar código quanto a vulnerabilidades de injeção de regex](../code-quality/ca3012.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de Regex. Um invasor pode usar a injeção de Regex para modificar uma expressão regular de forma mal-intencionada, para fazer com que o Regex coincida com resultados indesejados ou para fazer com que o Regex consuma CPU excessiva, resultando em um ataque de negação de serviço.|
|[CA3061: Não adicionar esquema por URL](../code-quality/ca3061.md)|Não use a sobrecarga não segura do método Add, pois isso pode causar referências externas perigosas.|
|[CA3075: Processamento de DTD não seguro](../code-quality/ca3075.md)|Se você usar instâncias DTDProcessing inseguras ou referenciar fontes externas de entidade, o analisador poderá aceitar entrada não confiável e divulgar informações confidenciais a invasores.|
|[CA3076: Execução de script XSLT não seguro](../code-quality/ca3076.md)|Se você executar a XSLT (Extensible Stylesheet Language Transformations) em aplicativos .NET de forma insegura, o processador poderá resolver referências de URI não confiáveis que poderiam divulgar informações confidenciais para invasores, levando à negação de serviço e a ataques entre sites.|
|[CA3077: Processamento não seguro no design de API, no documento XML e no leitor de texto XML](../code-quality/ca3077.md)|Ao criar uma API derivada de XMLDocument e XMLTextReader, lembre-se de DtdProcessing. Usar instâncias DTDProcessing inseguras ao referenciar ou resolver fontes de entidade externas ou definir valores inseguros no XML pode levar à divulgação de informações.|
|[CA3147: Marcar manipuladores de verbo com ValidateAntiForgeryToken](../code-quality/ca3147.md)|Ao criar um controlador MVC ASP.NET, lembre-se de ataques de solicitação entre sites forjado. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para o controlador MVC ASP.NET.|
|[As declarações P/Invoke CA5122 não devem ser críticas de segurança](../code-quality/ca5122.md)|Os métodos são marcados como SecuritySafeCritical quando executam uma operação confidencial de segurança, mas também são seguros para serem usados pelo código transparente. O código transparente jamais pode chamar diretamente o código nativo por meio de um P/Invoke. Por isso, a marcação de um P/Invoke como crítico de segurança não permitirá que o código transparente o chame, e é enganosa na análise de segurança.|
|[CA5359: Não desabilitar a validação de certificado](../code-quality/ca5359.md)|Um certificado pode ajudar a autenticar a identidade do servidor. Os clientes devem validar o certificado do servidor para garantir que as solicitações sejam enviadas ao servidor pretendido. Se o ServerCertificateValidationCallback sempre retornar `true` , qualquer certificado passará na validação.|
|[CA5360: Não chamar métodos perigosos durante a desserialização](../code-quality/ca5360.md)|A desserialização insegura é uma vulnerabilidade que ocorre quando dados não confiáveis são usados para proutilizar a lógica de um aplicativo, causarem um ataque de negação de serviço (DoS) ou até mesmo executar um código arbitrário quando ele estiver desserializado. Frequentemente, é possível que usuários mal-intencionados abusam esses recursos de desserialização quando o aplicativo estiver desserializando dados não confiáveis que estão sob seu controle. Especificamente, invoque métodos perigosos no processo de desserialização. Ataques de desserialização inseguros com êxito podem permitir que um invasor execute ataques, como ataques de DoS, desvios de autenticação e execução remota de código.|
|[CA5361: Não desabilite o uso de criptografia forte do SChannel](../code-quality/ca5361.md)|`Switch.System.Net.DontEnableSchUseStrongCrypto`A configuração para `true` enfraquece a criptografia usada em conexões TLS (segurança da camada de transporte) de saída. A criptografia mais fraca pode comprometer a confidencialidade da comunicação entre o aplicativo e o servidor, tornando mais fácil para os invasores bisbilhotarem dados confidenciais.|
|[CA5362: Ciclo de referência potencial no grafo de objetos desserializado](../code-quality/ca5362.md)|Se estiver desserializando dados não confiáveis, qualquer código que processe o grafo de objeto desserializado precisará manipular os ciclos de referência sem entrar em loops infinitos. Isso inclui o código que faz parte de um retorno de chamada de desserialização e o código que processa o grafo de objeto após a desserialização ser concluída. Caso contrário, um invasor pode executar um ataque de negação de serviço com dados mal-intencionados que contenham um ciclo de referência.|
|[CA5363: Não desabilitar a validação de solicitação](../code-quality/ca5363.md)|A validação de solicitação é um recurso no ASP.NET que examina as solicitações HTTP e determina se elas contêm conteúdo potencialmente perigoso que pode levar a ataques de injeção, incluindo scripts entre sites.|
|[CA5364: Não use protocolos de segurança preteridos](../code-quality/ca5364.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5365: Não desabilitar a verificação de cabeçalho HTTP](../code-quality/ca5365.md)|A verificação de cabeçalho HTTP permite a codificação do retorno de carro e dos caracteres de nova linha, \r e \n, que são encontrados nos cabeçalhos de resposta. Essa codificação pode ajudar a evitar ataques de injeção que exploram um aplicativo que ecoa dados não confiáveis contidos no cabeçalho.|
|[CA5366: Usar XmlReader para XML da leitura do conjunto de dados](../code-quality/ca5366.md)|Usar um <xref:System.Data.DataSet> para ler XML com dados não confiáveis pode carregar referências externas perigosas, que devem ser restringidas usando um <xref:System.Xml.XmlReader> com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5367: Não serializar tipos com campos de ponteiro](../code-quality/ca5367.md)|Esta regra verifica se há uma classe serializável com um campo ou propriedade de ponteiro. Os membros que não podem ser serializados podem ser um ponteiro, como membros estáticos ou campos marcados com <xref:System.NonSerializedAttribute> .|
|[CA5368: Definir ViewStateUserKey para as classes derivadas da página](../code-quality/ca5368.md)|Definir a <xref:System.Web.UI.Page.ViewStateUserKey> propriedade pode ajudá-lo a evitar ataques em seu aplicativo, permitindo que você atribua um identificador à variável de estado de exibição para usuários individuais para que os invasores não possam usar a variável para gerar um ataque. Caso contrário, haverá vulnerabilidades para falsificação de solicitação entre sites.|
|[CA5369: Usar o XmlReader para desserializar](../code-quality/ca5369.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas, que devem ser restringidas com o uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5370: Usar o XmlReader para validar o leitor](../code-quality/ca5370.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. Esse carregamento perigoso pode ser restringido usando um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5371: Usar o XmlReader para a leitura do esquema](../code-quality/ca5371.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. O uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado restringe isso.|
|[CA5372: Usar o XmlReader para o XPathDocument](../code-quality/ca5372.md)|O processamento de XML de dados não confiáveis pode carregar referências externas perigosas, que podem ser restringidas usando um XmlReader com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5373: Não usar a função de derivação de chave obsoleta](../code-quality/ca5373.md)|Essa regra detecta a invocação de métodos de derivação de chave fraca <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> e `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>usou um algoritmo fraco de PBKDF1.|
|[CA5374: Não usar XslTransform](../code-quality/ca5374.md)|Essa regra verifica se <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> é criada uma instância no código. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType>Agora é obsoleto e não deve ser usado.|
|[CA5375: Não usar a assinatura de acesso compartilhado da conta](../code-quality/ca5375.md)|Uma SAS de conta pode delegar acesso a operações de leitura, gravação e exclusão em contêineres de BLOB, tabelas, filas e compartilhamentos de arquivos que não são permitidos com uma SAS de serviço. No entanto, ele não dá suporte a políticas em nível de contêiner e tem menos flexibilidade e controle sobre as permissões concedidas. Depois que os usuários mal-intencionados o obtiverem, sua conta de armazenamento será comprometida facilmente.|
|[CA5376: Usar SharedAccessProtocol HttpsOnly](../code-quality/ca5376.md)|SAS são dados confidenciais que não podem ser transportados em texto sem formatação em HTTP.|
|[CA5377: Usar política de acesso no nível de contêiner](../code-quality/ca5377.md)|Uma política de acesso no nível de contêiner pode ser modificada ou revogada a qualquer momento. Ele fornece maior flexibilidade e controle sobre as permissões concedidas.|
|[CA5378: Não desabilite ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Configuração `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` para `true` limita as conexões de TLS (segurança de camada de transporte) do Windows Communication Framework (WCF) usando o TLS 1,0. Essa versão do TLS será preterida.|
|[CA5379: Não usar o algoritmo de função de derivação de chaves fraca](../code-quality/ca5379.md)|A <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe assume como padrão o uso do <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algoritmo. Você deve especificar o algoritmo de hash a ser usado em algumas sobrecargas do construtor com <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> ou superior. Observe <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> que Property tem apenas um `get` acessador e não tem um `overriden` modificador.|
|[CA5380: Não adicionar certificados ao repositório raiz](../code-quality/ca5380.md)|Essa regra detecta o código que adiciona um certificado ao repositório de certificados das autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs públicas que atendem aos requisitos do programa de certificado raiz da Microsoft.|
|[CA5381: Verificar que os certificados não sejam adicionados ao repositório raiz](../code-quality/ca5381.md)|Essa regra detecta o código que potencialmente adiciona um certificado ao repositório de certificados de autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs (autoridades de certificação) públicas que atendem aos requisitos do Microsoft Root Certificate Program.|
|[CA5382: Usar cookies seguros no ASP.NET Core](../code-quality/ca5382.md)|Os aplicativos disponíveis via HTTPS devem usar cookies seguros, que indicam ao navegador que o cookie só deve ser transmitido usando TLS (Transport Layer Security).|
|[CA5383: Garantir o uso de cookies seguros no ASP.NET Core](../code-quality/ca5383.md)|Os aplicativos disponíveis via HTTPS devem usar cookies seguros, que indicam ao navegador que o cookie só deve ser transmitido usando TLS (Transport Layer Security).|
|[CA5384: Não usar o DSA (algoritmo de assinatura digital)](../code-quality/ca5384.md)|O DSA é um algoritmo de criptografia assimétrica fraco.|
|[CA5385: Usar o algoritmo RSA (Rivest–Shamir–Adleman) com um tamanho de chave suficiente](../code-quality/ca5385.md)|Uma chave RSA inferior a 2048 bits é mais vulnerável a ataques de força bruta.|
|[CA5386: Evitar codificar o valor SecurityProtocolType](../code-quality/ca5386.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo e ter como destino pelo menos .NET Framework v 4.7.1.|
|[CA5387: Não usar a função de derivação de chaves fraca com uma contagem de iteração insuficiente](../code-quality/ca5387.md)|Esta regra verifica se uma chave criptográfica foi gerada por <xref:System.Security.Cryptography.Rfc2898DeriveBytes> com uma contagem de iteração inferior a 100.000. Uma contagem de iteração mais alta pode ajudar a mitigar contra ataques de dicionário que tentam adivinhar a chave de criptografia gerada.|
|[CA5388: Assegurar uma contagem de iteração suficiente ao usar a função de derivação de chaves fraca](../code-quality/ca5388.md)|Esta regra verifica se uma chave de criptografia foi gerada pelo <xref:System.Security.Cryptography.Rfc2898DeriveBytes> com uma contagem de iteração que pode ser menor que 100.000. Uma contagem de iteração mais alta pode ajudar a mitigar contra ataques de dicionário que tentam adivinhar a chave de criptografia gerada.|
|[CA5389: Não adicionar o caminho do item de arquivo ao caminho do sistema de arquivos de destino](../code-quality/ca5389.md)|O caminho do arquivo pode ser relativo e pode levar ao acesso do sistema de arquivos fora do caminho de destino do sistema de arquivos esperado, levando a alterações de configuração mal-intencionadas e à execução remota de código por meio da técnica de Lay-and-wait.|
|[CA5390: Não embutir a chave de criptografia em código](../code-quality/ca5390.md)|Para que um algoritmo simétrico seja bem-sucedido, a chave secreta deve ser conhecida somente pelo remetente e pelo destinatário. Quando uma chave é embutida em código, ela é facilmente descoberta. Mesmo com binários compilados, é fácil para usuários mal-intencionados extraí-lo. Depois que a chave privada for comprometida, o texto cifrado poderá ser descriptografado diretamente e não será mais protegido.|
|[CA5391: Usar tokens antifalsificação em controladores MVC do ASP.NET Core](../code-quality/ca5391.md)|Manipular uma `POST` `PUT` solicitação,, `PATCH` ou `DELETE` sem validar um token de antifalsificação pode estar vulnerável a ataques de solicitação entre sites forjada. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para seu controlador ASP.NET Core MVC.|
|[CA5392: Usar o atributo DefaultDllImportSearchPaths para P/Invokes](../code-quality/ca5392.md)|Por padrão, as funções P/Invoke usam a <xref:System.Runtime.InteropServices.DllImportAttribute> investigação de um número de diretórios, incluindo o diretório de trabalho atual para a biblioteca carregar. Isso pode ser um problema de segurança para determinados aplicativos, levando ao seqüestro de DLL.|
|[CA5393: Não usar o valor DllImportSearchPath não seguro](../code-quality/ca5393.md)|Pode haver uma DLL mal-intencionada nos diretórios de pesquisa padrão de DLL e no assembly. Ou, dependendo de onde o aplicativo é executado, pode haver uma DLL mal-intencionada no diretório do aplicativo.|
|[CA5394: Não usar aleatoriedade não segura](../code-quality/ca5394.md)|O uso de um gerador de números pseudo aleatórios criptograficamente fraco pode permitir que um invasor preveja qual valor de segurança será gerado.|
|[CA5395: Ignorar o atributo HttpVerb para métodos de ação](../code-quality/ca5395.md)|Todos os métodos de ação que criam, editam, excluem ou modificam os dados precisam ser protegidos com o atributo antifalsificação de ataques de falsificação de solicitação entre sites. A execução de uma operação GET deve ser uma operação segura que não tenha efeitos colaterais e não modifique seus dados persistentes.|
|[CA5396: Definir HttpOnly como true para HttpCookie](../code-quality/ca5396.md)|Como uma medida de defesa profunda, verifique se os cookies HTTP sensíveis à segurança estão marcados como HttpOnly. Isso indica que os navegadores da Web devem impedir que os scripts acessem os cookies. Scripts maliciosos injetados são uma maneira comum de roubar cookies.|
|[CA5397: Não usar valores de SslProtocols preteridos](../code-quality/ca5397.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5398: Evitar valores de SslProtocols fixos](../code-quality/ca5398.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo.|
|[CA5399: Desabilitar definitivamente a verificação da lista de certificados revogados do HttpClient](../code-quality/ca5399.md)|Um certificado revogado não é mais confiável. Ele pode ser usado por invasores passando dados mal-intencionados ou roubando dados confidenciais na comunicação HTTPS.|
|[CA5400: Certificar-se de que a verificação da lista de certificados revogados do HttpClient não está desabilitada](../code-quality/ca5400.md)|Um certificado revogado não é mais confiável. Ele pode ser usado por invasores passando dados mal-intencionados ou roubando dados confidenciais na comunicação HTTPS.|
|[CA5401: Não usar CreateEncryptor com IV não padrão](../code-quality/ca5401.md)|A criptografia simétrica sempre deve usar um vetor de inicialização não reproduzível para evitar ataques de dicionário.|
|[CA5402: Usar CreateEncryptor com o IV padrão](../code-quality/ca5402.md)|A criptografia simétrica sempre deve usar um vetor de inicialização não reproduzível para evitar ataques de dicionário.|
