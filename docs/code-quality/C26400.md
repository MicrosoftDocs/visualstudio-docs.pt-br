---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016622"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Essa verificação ajuda a impor o *rule I. 11: Nunca transfira a propriedade por um ponteiro bruto (T @ no__t-0)* , que é um subconjunto da regra *R. 3: Um ponteiro bruto (um T @ no__t-0) não é proprietário.* Especificamente, ele avisa sobre qualquer chamada para o operador `new`, que salva seu resultado em uma variável de tipo de ponteiro bruto. Ele também avisa sobre chamadas para funções que retornam `gsl::owner<T>` se seus resultados são atribuídos a ponteiros brutos. A ideia aqui é que você deve declarar claramente a propriedade dos recursos de memória. Para obter mais informações, consulte as [ C++ diretrizes básicas](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

A maneira mais fácil de corrigir isso é usar a declaração `auto` se o recurso for atribuído imediatamente na declaração de variável. Se isso não for possível, sugerimos que você use o tipo `gsl::owner<T>`. As declarações `auto` inicializadas com o operador `new` são "proprietários" porque supomos que o resultado de qualquer alocação é implicitamente um ponteiro de proprietário. Transferimos essa suposição para a variável `auto` e a trata como `owner<T>`.

Se essa verificação sinalizar uma chamada para uma função que retorna `owner<T>`, isso pode ser uma indicação de um bug legítimo no código. Basicamente, ele aponta para um local onde o código vaza uma noção explícita de propriedade (e talvez o próprio recurso).

## <a name="remarks"></a>Comentários

Atualmente, essa regra verifica apenas as variáveis locais. Se a alocação for atribuída a um parâmetro formal, uma variável global, um membro de classe e assim por diante, ela não será sinalizada. A cobertura apropriada desses cenários é parte do trabalho futuro.

## <a name="example-1-simple-allocation"></a>Exemplo 1: Alocação simples

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Exemplo 2: Alocação simples (fixa com GSL:: Owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
