---
title: C26410
ms.date: 07/21/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26410
helpviewer_keywords:
- C26410
ms.assetid: d1547faf-96c6-48da-90f5-841154d0e878
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: a815e77562bab57c78081cbb171f5ec4e6538f88
ms.sourcegitcommit: 2193323efc608118e0ce6f6b2ff532f158245d56
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/25/2019
ms.locfileid: "54954696"
---
# <a name="c26410--noreftoconstuniqueptr"></a>C26410  NO_REF_TO_CONST_UNIQUE_PTR
Em geral, as referências ao ponteiro exclusivo const não fazem sentidas. Eles podem ser substituídos com segurança por uma referência bruta ou um ponteiro.

## <a name="remarks"></a>Comentários
- Verificações de ponteiro exclusivo têm bastante amplas critérios para identificar os ponteiros inteligentes. A regra R.31: *Se você tiver não std ponteiros inteligentes, siga o padrão básico de std descreve o ponteiro exclusivo e compartilhado conceitos de ponteiro*. A heurística é simple, mas pode levar a surpresas: um tipo de ponteiro inteligente é qualquer tipo que define o operador -> ou o operador\*; um tipo capaz de cópia (ponteiro compartilhado) deve ter o construtor de cópia público ou o operador de atribuição sobrecarregados que lida com um parâmetro de referência não-R-value.
- Código de modelo pode produzir muito ruído. Tenha em mente que os modelos podem ser instanciados com vários parâmetros de tipo com diferentes níveis de indireção, incluindo referências. Alguns avisos podem não ser óbvios e correções podem exigir uma reformulação de modelos (por exemplo, remoção explícita de indireção de referência). Se o código de modelo é intencionalmente genérico, o aviso pode ser suprimido.

## <a name="example-1-unnecessary-reference"></a>Exemplo 1: Referência desnecessária
```cpp
std::vector<std::unique_ptr<Tree>> roots = GetRoots();
std::for_each(
    roots.begin(),
    roots.end(),
    [](const auto &root) { Rebalance(root.get()); });   // C26410
```