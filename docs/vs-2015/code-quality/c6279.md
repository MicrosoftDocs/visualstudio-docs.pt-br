---
title: C6279 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6279
helpviewer_keywords:
- C6279
ms.assetid: 0af88b58-35df-456f-8c02-e8eeffe3b7de
caps.latest.revision: 15
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 3d343438decf92e3b3ea28de77f512b82fc7237a
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/02/2020
ms.locfileid: "77278122"
---
# <a name="c6279"></a>C6279
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

aviso C6279: \<variable> está alocado com escalar novo, excluído por matriz DELETE []  
  
 Esse aviso aparece apenas no código C++ e indica que a função de chamada tem memória inconsistente alocada com o operador **New** escalar, mas liberou-a com o operador **delete []** da matriz. Se a memória for alocada com o escalar **novo**, ela normalmente deverá ser liberada com a **exclusão**escalar.  
  
 Há pelo menos três motivos pelos quais isso provavelmente causará problemas:  
  
- Os construtores para os objetos individuais na matriz não são invocados, embora os destruidores sejam.  
  
- Se o operador global (ou específico de classe) **novo** e o **operador Delete** não forem compatíveis com o **operador new []** e **Operator Delete []**, poderão ocorrer resultados inesperados.  
  
  As ramificações exatas desse defeito são difíceis de prever. Isso pode causar comportamento aleatório ou falhas devido ao uso de memória não inicializada porque os construtores não são invocados. Ou, isso pode causar alocações de memória e falhas em situações em que os operadores foram substituídos. Em casos raros, a incompatibilidade pode não ser importante. Atualmente, a ferramenta de análise não faz distinção entre essas situações.  
  
## <a name="example"></a>Exemplo  
 O código a seguir gera este aviso:  
  
```cpp  
class A  
{  
  // members  
};  
  
void f ( )  
{  
  A *pA = new A;  
  //code ...  
  delete[] pA;  
}  
```  
  
 Para corrigir esse aviso, use o seguinte código:  
  
```cpp  
void f( )  
{  
  A *pA = new A;  
  //code ...  
  delete pA;  
}  
```  
  
 Para evitar esses tipos de problemas de alocação totalmente, use os mecanismos fornecidos pela STL (biblioteca de modelos padrão) do C++. Isso inclui [shared_ptr](https://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](https://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a)e [vetor](https://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Para obter mais informações, consulte [apontadores inteligentes](https://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) e a [biblioteca padrão C++](https://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
## <a name="see-also"></a>Consulte Também  
 [C6014](../code-quality/c6014.md)
